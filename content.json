{"pages":[{"title":"about","text":"About Me? Who am I? 一个安静码代码的小透明。我的标签？ 技术宅、捡屎官、强迫症、处女座倾向的双鱼女、爱学习爱生活、爱宠物、生命不息，奋斗不止…啦啦啦~我擅长什么？ JS？No No No，路还很长，怎么能说自己精通呢？嗯，那就熟练吧。 CSS？嗯，一切不以美为原则的CSS都是在扯淡~~百分百还原UI？too young~ 框架？Vue,React都是好东西，用起来当然顺手，不过重点在于其原理呀。 建站？嗯，前端是专业，那么后端，运维领域的入门就属于我对这一行的好奇心了。 还有呢？无限可能~~我的爱好？ 捡屎官，我的狗子豌豆，很可爱的金毛，阳光帅气大暖男~~长下面这样~ Photoshope，PS自拍？不不不，自拍太low，还是给自己加点物资，duang~duang~duang的那种才秀 学习，嗯，可能我有点学习焦虑症 我的简历，扫一扫查看","link":"/about/index.html"}],"posts":[{"title":"2019前端技能目标","text":"先定一个小目标，万一全都实现了呢？生活上的小目标就不记录在这儿了，这里只写职业生涯的目标。 [ ] React及Vue达到精通的程度 [ ] 开始学习Reason（以及Reason React）然后做个业余项目试试吧。 [ ] 学习GraphQL【API的查询语言（可以看成是REST的现代版）】。 [ ] 在一个项目上安装Prettier，让代码可读性更强。 [ ] 使用Jest结合Puppeteer测试一下React应用。 [ ] 熟悉Typescript，并完成一个小项目 [ ] 用React Native开发一个移动app。 [ ] 用Electron开发一个桌面app。 [ ] 玩一下Popmotion创作一个流畅的动画。 [ ] Node达到熟练的程度，并对其生态（koa,express）熟练使用 [ ] Canvas，D3，做炫酷动画 [ ] 学习github上的一些复杂项目的写法 [ ] 翻译一篇国外技术文章 [ ] 能够轻松的看懂国外技术网站的文章 [ ] Vue结合Nuxt.js实现SSR，React结合Next.js实现SSR [ ] 能独立配置webpack实现项目构建 [ ] 基础！基础！基础！（HTML，Javascript,CSS3精通精通） [ ] 阅读一个前端应用框架或工具的源码 [ ] 使用websocket建立一个聊天室 [ ] 建立一个宠物信息类网站或APP或小程序（可跨年）","link":"/2019/01/03/2019前端技能目标/"},{"title":"JavaScript模式【O'Reilly出版】·附网盘链接","text":"模式：指一个通用问题的解决方案。一个模式不仅仅是一个可以用来复制粘贴的代码解决方案，更多地是提供了一个更好的实践经验、有用的抽象化表示和解决一类问题的模板。 目录 PDF地址 基本技巧 字面量和构造函数 PDF地址 网盘地址：https://pan.baidu.com/s/1Kwgim2OQL86hSGjZftTR4Q 云盘密码：qizu 基本技巧编写可维护的代码易维护的代码意味着代码具有如下特性: 阅读性好 具有一致性 预见性好 看起来如同一个人编写 有文档 尽量少用全局变量 变量释放时的副作用 全局变量不能通过delete删除，而对象的属性可以 编码时的建议 单一的var模式：在函数内部，将变量的定义放在函数头部,便于维护，提高代码要读性。 对for循环的建议： 逐步减至0，这样通常更快，因为同0比较比同数组的长度比较，或者同非0数组比较更有效率。 实践证明，while循环速度更快 123var i,arr=[];// 改进：使用while循环while(i--){//xxx} 对for…in循环的建议： for...in又称为枚举,用于处理对象。在遍历对象属性来过滤遇到原型链的属性时，可通过obj.hasOwnProperty|Object.property.hasOwnProperty.call(xxx)来检测key是否为对象本身属性。 不要增加内置的原型 避免使用隐式类型转换：为避免隐式类型转换导致的混乱，在使用比较廒时，应该使用===或!===来对数值和类型进行比较 避免使用eval() parseInt()数值约定：在使用parseInt时，最好不要忽略第二个参数（进制），因为带val第一位是0时，其会被当做一个八进制数进行处理【例如处理09这种月份日期时】，最佳实践：parseInt(num,10) 空格的使用 ： 在for循环的各个部分的分号后，建议添加空格，for(var i=0, max=4; i&lt;max; i++){} 在限定数组项的逗号后面： var a = [ 1, 2, 3] 分隔开函数中各个参数的逗号之后 ： myFun = function(a, b, c) 在函数声明的大括号之前 : function myFun() {} 在匿名函数表达式之后 ： var myFun = function () {} 命名约定 构造函数的首字母大写 针对多个单词组成的变量名，推荐使用驼峰式命名法或下划线连接 常量命名通常使用全大写的方式 私有变量命名通常给变量名加下划线前缀var _private = 1 编写API文档 API文档可以从代码的注释中自动生成。 在JS中，推荐两个开源工具可用于编写JS文档，分别是JSDoc Toolkit和YUIDoc 生成API文档的步骤如下： 编写特殊格式的代码块 运行工具来解析代码和注释 发布工具解析的结果，大多数情况是采用HTML格式发布 示例：有一个名为reverse()的函数，可以将字符串翻转过来，该函数有一个字符串参数，并返回另一个字符串 1234567/*** 翻转一个字符串* * @param {String} 输入需要翻转的字符串* @return {String} 翻转后的字符串*/var reverse = function (input) {return output;} 在正式发布时，精简代码 字面量和构造函数","link":"/2018/02/10/JS模式/"},{"title":"Nginx免费视频教程","text":"作为一个前端，我相信你一定听说过Nginx。因为它在最近两年实在是太火了，作为一个前端如果不会Nginx，都不敢跟别人说自己是大前端。那Nginx到底是什么？我们还是引用官方的介绍吧： “Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。” 引用自：一个前端的2018总结，2019展望 | 掘金年度征文 课程说明 第01节:初识Nginx和环境准备 第02节:Nginx的快速搭建 第03节：Nginx基本配置文件详讲 第04节：Nginx服务启动、停止、重启 第05节：自定义错误页和访问设置 第06节：Nginx访问权限详讲 第07节：Nginx设置虚拟主机 第08节：Nginx使用域名设置虚拟主机 第09节：Nginx反向代理的设置 第10节：Nginx适配PC或移动设备 第11节：Nginx的Gzip压缩配置 教程地址 初识Nginx和环境准备：jspang.com/post/nginx.… Nginx的快速搭建：jspang.com/post/nginx.… Nginx基本配置文件详讲:jspang.com/post/nginx.… Nginx服务启动、停止、重启:jspang.com/post/nginx.… 自定义错误页和访问设置:jspang.com/post/nginx.… Nginx访问权限详讲:jspang.com/post/nginx.… Nginx设置虚拟主机:jspang.com/post/nginx.… Nginx使用域名设置虚拟主机:jspang.com/post/nginx.… Nginx反向代理的设置:jspang.com/post/nginx.… Nginx适配PC或移动设备：jspang.com/post/nginx.… Nginx的Gzip压缩配置：jspang.com/post/nginx.…","link":"/2019/01/07/Nginx免费视频教程/"},{"title":"《CSS揭秘》Demo笔记","text":"《CSS揭秘》一书揭示了 47 个鲜为人知的 CSS 技巧，主要内容包括背景与边框、形状、 视觉效果、字体排印、用户体验、结构与布局、过渡与动画等。本书将带领读者循序渐进地探寻更优雅的解决方案，攻克每天都会遇到的各种网页样式难题。 DRY: don’t repeat yourself,减少代码重复 WET：we enjoy typing/write everything twice,与DRY正相反 一、背景与边框 半透明边框 原理：利用background-clip:padding-box实现背景色不占用边框底部（默认情况下background-clip的初始值是border-box，这意味着当边框设置半透明色值时，显示的会是背景色叠加透明色的效果） 多重边框 原理：1、利用box-shadow可以创建任意数量的投影（实色即边框），但注意投影是不占用元素布局的。 2、利用outline实现双重边框 灵活背景定位 原理：background-positioon:right 10px bottom 20px;指背景位置距离右边10px，距离底部20px. background-origin 作用：用于设置背景的原始位置依据，值为content-box,padding-box,border-box; calc()方案 边框内圆角 原理：利用outline和box-shadow组合实现内圆角（outline目前没有实现圆角） 方法二：两个元素来实现，当然这样增加了额外的html标签 横向条纹背景 原理：利用bacground:linear-gradient(red 50%,green 50%)实现双条纹，利用background-size:100% 30px实现单个条纹高15px 垂直条纹背景 原理：设置linear-gradient角度为90deg，或to right，通过background-size:30px 100%设置条纹单个宽15px 斜向条纹 原理：45deg斜向条纹，利用 勾股定理计算出 条纹若30px时，需要background-size对应的值 60度斜向条纹 原理：通过background:repeating-linear-gradient(60deg,red,red 15px,blue 15px ,blue 30px)实现 灵活同色系条纹 应用场景：如bootstrap的进度条，由深色背景+同色系浅背景的斜条纹组成 原理：同色系深色作为背景色，再通过叠加白色半透明和透明条纹，实现深浅间隔条纹 蓝色网格背景 原理：利用background-image:linear-gradient()支持分隔叠加的属性方式 波点背景图 原理：利用background:radial-gradient(green 30%,transparent 0)实现，径向渐变由内向外 棋盘 svg实现棋盘 角向渐变 作用：可用于实现取色的色轮 伪随机背景 作用：实现随机宽度的竖直条纹 动态loading图 原理：通过叠加多个animation，实现连续动画效果（旋转，变色，边框宽度增加） 连续的图像边框 原理：通过叠加纯白背景（渐变实现，padding-box）和图像背景（border-box） 信封边缘背景 原理：通过叠加纯白渐变背景（padding-box)和-45deg条纹渐变（borderbox) 边框背景图实现信封边缘 原理：通过border-image值为线性渐变的条纹而实现 移动的虚线边框 原理：利用背景叠加实现虚线边框，通过animation实现背景移动产生动态效果 字体脚注效果 原理：利用border-image属性加一条线性渐变产生的垂直条纹，border-width控制边框粗线，渐变长度来控制脚注长度 二、形状 椭圆 原理：使用border-radius:50%实现 半椭圆 原理：利用border-radius可以使用/分隔开水平和垂直方向上的圆角值特性来分别设置不同方式上的圆角半径 四分之一椭圆 原理：border-radius只设置一个角的圆弧 平行四边形 原理：transform:skew()变形。（注意：行内元素无效） 平行四边形伪元素方案 原理：利用伪元素来变形，从而不影响元素内部正常内容（变形元素内部的内容也会变形） 菱形图片裁切 原理：嵌套元素，内外反向rotate，内部图片宽度与对角线平齐.(内部反向rotate是为了摆正图片) 菱形裁切方案二 原理：利用clip-path裁切路径属性，设置其值为polygon()多边形来实现 元素切角 原理：利用渐变（透明到实色）实现角度，利用background-size控制多个渐变互不影响实现多个切角 元素弧形切角 原理：利用径向渐变实现，多个圆角与上述同理 border-image实现切角 原理：运用border-image结合svg图实现切角边框，通过background-clip限制背景色 裁切路径实现切角 原理：运用clip-path:polygon()实现，局限兼容性不好，裁切会忽略内部文本内容。优点：可裁切任意内容，不受背景图限制 梯形导航tab效果 原理：运用transform:perspective()实现穿透变形 动态饼图 原理：伪元素遮盖旋转 静态饼图 svg实现饼图 三、视觉效果 单侧投影 原理：利用box-shadow的3个大小值外，第4个长度参数（扩张半径），当扩张半径为负的模糊半径时，即可实现单侧投影 邻边投影 原理：设置双侧位移，并设置扩张半径为模糊半径值一半 对侧投影 原理：叠加两个单侧投影 不规则图形投影 原理：利用CSS滤镜filter:drop-shadow()实现 染色效果 原理：通过多个滤镜结合实现效果 染色效果-混合模式 原理：利用CSS混合模式属性，设置两层背景混合效果，mix-blend-mode:是混合叠加两个元素的效果，background-blend-mode是设置两层背景图的混合效果。luminosity表示混合模式 毛玻璃效果 原理：利用CSS滤镜filter:blur()实现模糊，通过模糊伪元素再叠加到元素底部实现。（细节：滤镜默认靠近边框时效果会减弱，因此在设置blur值时，最好多设大一点） 折角效果 原理：利用切角效果 ，结合叠加一个深色三角形 多角度折角效果 mixin实现折角 四、字体排印 连字符断行 效果不理想（兼容性不好） 插入换行 原理：运用unicode中的换行符0x000A,在CSS中即为\\000A（简写为\\A）来作为伪元素的content值，同时注意保留换行符和空白符white-space:pre 文本行斑马条纹 原理：利用条纹背景实现条纹，再利用背景em值作为条纹大小 调整tab的宽度 原理：通过CSS3新增文本属性tab-size:2;来设置每个tab占2个字符宽度 连字 华丽的&amp;符号 原理：通过@font-face规则实现基本的字体嵌入 自定义下划线 原理：CSS渐变 ，background-size,text-shadow,‘条纹背景’【效果不理想】 波浪下划线 【效果不理想】 凸版印刷效果 空心字效果 文字外发光效果 原理：通过叠加多个text-shadow，运用transition过渡实现特效 文字突起效果 环形文字 原理：通过内联SVG来实现文字环形排版，还可以运用动画使其旋转。通过xlink:href属性来把元素内容链接到路径上 通过JS处理，把.circual类元素自动替换为相应的SVG 五、用户体验 选用合适的鼠标指针 原理：在不同场景下选用不同的鼠标指针。cursor属性设置 隐藏光标：cursor:none,对于老版本浏览器可以通过cursor:url(transparent.gif)来传入一张1*1的透明gif模拟隐藏 扩大可点击区域 原理：通过伪元素扩大按钮范围 扩大可点击区域 自定义复选框 原理：利用checkbox的:checked属性区分选中状态，再结合相邻label元素控制，通过伪元素实现想要的效果，再隐藏掉原复选框 开关式按钮 CSS遮罩层 原理：通过box-shadow实现。缺陷：遮罩层下还是可以操作 原生modal遮罩层 原理：通过 ::backdrop伪类实现遮罩 模糊背景弱化 原理：通过滤镜模糊filter:blur()模糊背景 滚动提示 应用场景：当可向下，或向上滚动时，提示出部分阴影 交互式图片对比控件 六、结构与布局 自适应内部元素 原理：通过CSS3新增属性min-content让元素宽度最大宽度为其内部不可断行的元素宽度， 精准控制表格列表 原理：通过设置table-layout:fixed把表格更多的控制权交到开发者手里，而不是让浏览器决定内容多少时变更理想的渲染宽度 根据兄弟元素的数量范围来匹配元素 原理：选择器:nth-child,兄弟选择符~结合使用 满幅背景，定宽内容 运用：通常情况下我们制作定宽内容版本居中时，会用到两个html元素，外层100%宽度，内层定宽并通过margin:auto居中。 优化：此方案通过纯CSS的方法来实现，且只需要一个元素就可以了 垂直居中 绝对定位解决方案 通过绝对定位结合translate实现水平垂直居中 基于视口单位的解决方案 只针对相对于整屏视口来做水平垂直居中的效果。利用margin:50vh auto 0实现对上50vh，再通过transform:translateY(-50%);实现居中 flexbox解决方案 CSS-Sticky-footer紧贴底部页脚 固定高度解决方案 原理：在已知页脚以及header高度的情况下，通过calc(100vh-header-footer)得到中间部分的min-height Flexbox解决方案 原理：通过弹性布局实现 更多解决方案可以搜索CSS-sticky-footer，上面两种方法都提倡不增加额外的html（因为这会影响性能） 七、过渡与动画 动画调速函数 弹跳球动画 CSS在提供了内置了几种缓动函数ease,linear,ease-in,ease-out,ease-in-out外，还提供了cubic-bezier()用于开发者定定义调速函数。 animate.css动画库 弹性过渡-popup动效 弹性过渡变色效果 逐帧动画-CSS实现Loading动态图 原理：通过把所有帧全部拼合到一张PNG图中，以一个一帧大小元素来容纳，变换background-position值实现帧过度，通过animation的steps()函数实现不平滑过度，从而显示每帧动画","link":"/2019/07/08/CSS揭秘Demo笔记/"},{"title":"PM2实用入门指南","text":"PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。 转载自博客园 下面就对PM2进行入门性的介绍，基本涵盖了PM2的常用的功能和配置。 安装全局安装，简直不能更简单。1$ npm install -g pm2 目录介绍 pm2安装好后，会自动创建下面目录。看文件名基本就知道干嘛的了，就不翻译了。 $HOME/.pm2 will contain all PM2 related files $HOME/.pm2/logs will contain all applications logs $HOME/.pm2/pids will contain all applications pids $HOME/.pm2/pm2.log PM2 logs $HOME/.pm2/pm2.pid PM2 pid $HOME/.pm2/rpc.sock Socket file for remote commands $HOME/.pm2/pub.sock Socket file for publishable events $HOME/.pm2/conf.js PM2 Configuration 入门教程 挑我们最爱的express应用来举例。一般我们都是通过npm start启动应用，其实就是调用node ./bin/www。那么，换成pm2就是 注意，这里用了--watch参数，意味着当你的express应用代码发生变化时，pm2会帮你重启服务，多贴心。1pm2 start ./bin/www --watch 入门太简单了，没什么好讲的。直接上官方文档：http://pm2.keymetrics.io/docs/usage/quick-start 常用命令启动参数说明： --watch：监听应用目录的变化，一旦发生变化，自动重启。如果要精确监听、不见听的目录，最好通过配置文件。 -i --instances：启用多少个实例，可用于负载均衡。如果-i 0或者-i max，则根据当前机器核数确定实例数目。 --ignore-watch：排除监听的目录/文件，可以是特定的文件名，也可以是正则。比如–ignore-watch=”test node_modules “some scripts”” -n --name：应用的名称。查看应用信息的时候可以用到。 -o --output &lt;path&gt;：标准输出日志文件的路径。 -e --error &lt;path&gt;：错误输出日志文件的路径。 --interpreter &lt;interpreter&gt;：the interpreter pm2 should use for executing app (bash, python…)。比如你用的coffee script来编写应用。 完整命令行参数列表：地址 1pm2 start app.js --watch -i 2 重启1pm2 restart app.js 停止停止特定的应用。可以先通过pm2 list获取应用的名字（–name指定的）或者进程id。 1234pm2 stop app_name|app_id# 停止所有应用pm2 stop all 删除12pm2 stop app_name|app_idpm2 stop all 查看进程状态1pm2 list 查看某个进程的信息123456789101112131415161718192021[root@iZ94wb7tioqZ pids]# pm2 describe 0Describing process with id 0 - name oc-server┌───────────────────┬──────────────────────────────────────────────────────────────┐│ status │ online ││ name │ oc-server ││ id │ 0 ││ path │ /data/file/qiquan/over_the_counter/server/bin/www ││ args │ ││ exec cwd │ /data/file/qiquan/over_the_counter/server ││ error log path │ /data/file/qiquan/over_the_counter/server/logs/app-err-0.log ││ out log path │ /data/file/qiquan/over_the_counter/server/logs/app-out-0.log ││ pid path │ /root/.pm2/pids/oc-server-0.pid ││ mode │ fork_mode ││ node v8 arguments │ ││ watch &amp; reload │ ││ interpreter │ node ││ restarts │ 293 ││ unstable restarts │ 0 ││ uptime │ 87m ││ created at │ 2016-08-26T08:13:43.705Z │└───────────────────┴──────────────────────────────────────────────────────────────┘ 配置文件简单说明 配置文件里的设置项，跟命令行参数基本是一一对应的。 可以选择yaml或者json文件，就看个人洗好了。 json格式的配置文件，pm2当作普通的js文件来处理，所以可以在里面添加注释或者编写代码，这对于动态调整配置很有好处。 如果启动的时候指定了配置文件，那么命令行参数会被忽略。（个别参数除外，比如–env） 例子举个简单例子，完整配置说明请参考官方文档。12345678910111213141516171819202122{ \"name\" : \"fis-receiver\", // 应用名称 \"script\" : \"./bin/www\", // 实际启动脚本 \"cwd\" : \"./\", // 当前工作路径 \"watch\": [ // 监控变化的目录，一旦变化，自动重启 \"bin\", \"routers\" ], \"ignore_watch\" : [ // 从监控目录中排除 \"node_modules\", \"logs\", \"public\" ], \"watch_options\": { \"followSymlinks\": false }, \"error_file\" : \"./logs/app-err.log\", // 错误日志路径 \"out_file\" : \"./logs/app-out.log\", // 普通日志路径 \"env\": { \"NODE_ENV\": \"production\" // 环境参数，当前指定为生产环境 }} 自动重启前面已经提到了，这里贴命令行，更多点击这里。1pm2 start app.js --watch 这里是监控整个项目的文件，如果只想监听指定文件和目录，建议通过配置文件的watch、ignore_watch字段来设置。 环境切换在实际项目开发中，我们的应用经常需要在多个环境下部署，比如开发环境、测试环境、生产环境等。在不同环境下，有时候配置项会有差异，比如链接的数据库地址不同等。 对于这种场景，pm2也是可以很好支持的。首先通过在配置文件中通过env_xx来声明不同环境的配置，然后在启动应用时，通过–env参数指定运行的环境。 环境配置声明首先，在配置文件中，通过env选项声明多个环境配置。简单说明下： env为默认的环境配置（生产环境），env_dev、env_test则分别是开发、测试环境。可以看到，不同环境下的NODE_ENV、REMOTE_ADDR字段的值是不同的。 在应用中，可以通过process.env.REMOTE_ADDR等来读取配置中生命的变量。123456789101112\"env\": { \"NODE_ENV\": \"production\", \"REMOTE_ADDR\": \"http://www.example.com/\"},\"env_dev\": { \"NODE_ENV\": \"development\", \"REMOTE_ADDR\": \"http://wdev.example.com/\"},\"env_test\": { \"NODE_ENV\": \"test\", \"REMOTE_ADDR\": \"http://wtest.example.com/\"} 启动指明环境假设通过下面启动脚本（开发环境），那么，此时process.env.REMOTE_ADDR的值就是相应的 http://wdev.example.com/ ，可以自己试验下。1pm2 start app.js --env dev 负载均衡命令如下，表示开启三个进程。如果-i 0，则会根据机器当前核数自动开启尽可能多的进程。12pm2 start app.js -i 3 # 开启三个进程pm2 start app.js -i max # 根据机器CPU核数，开启对应数目的进程 日志查看除了可以打开日志文件查看日志外，还可以通过pm2 logs来查看实时日志。这点对于线上问题排查非常重要。 比如某个node服务突然异常重启了，那么可以通过pm2提供的日志工具来查看实时日志，看是不是脚本出错之类导致的异常重启。1pm2 logs 指令tab补全运行pm2 --help，可以看到pm2支持的子命令还是蛮多的，这个时候，自动完成的功能就很重要了。运行如下命令。恭喜，已经能够通过tab自动补全了。细节可参考这里。12pm2 completion installsource ~/.bash_profile 开机自动启动可以通过pm2 startup来实现开机自启动。细节可参考。大致流程如下 通过pm2 save保存当前进程状态。 通过pm2 startup [platform]生成开机自启动的命令。（记得查看控制台输出） 将步骤2生成的命令，粘贴到控制台进行，搞定。传入node args直接上例子，分别是通过命令行和配置文件。 命令行：1pm2 start app.js --node-args=\"--harmony\" 配置文件：12345{ \"name\" : \"oc-server\", \"script\" : \"app.js\", \"node_args\" : \"--harmony\"} 实例说明假设是在centos下，那么运行如下命令，搞定。强烈建议运行完成之后，重启机器，看是否设置成功。1234567891011[root@iZ94wb7tioqZ option_analysis]# pm2 save[root@iZ94wb7tioqZ option_analysis]# pm2 startup centos[PM2] Generating system init script in /etc/init.d/pm2-init.sh[PM2] Making script booting at startup...[PM2] /var/lock/subsys/pm2-init.sh lockfile has been added[PM2] -centos- Using the command: su -c \"chmod +x /etc/init.d/pm2-init.sh; chkconfig --add pm2-init.sh\"[PM2] Done.[root@iZ94wb7tioqZ option_analysis]# pm2 save[PM2] Dumping processes 远程部署可参考官方文档，配置也不复杂，用到的时候再来填写这里的坑。TODO 官方文档：http://pm2.keymetrics.io/docs/usage/deployment/#getting-started 监控(monitor)运行如下命令，查看当前通过pm2运行的进程的状态。1pm2 monit 看到类似输出12345678910111213141516171819[root@oneday-dev0 server]# pm2 monit⌬ PM2 monitoring (To go further check out https://app.keymetrics.io) [ ] 0 %⌬ PM2 monitoring (To go further check o[||||||||||||||| ] 196.285 MB ● fis-receiver [ ] 0 %[1] [fork_mode] [||||| ] 65.773 MB ● www [ ] 0 %[2] [fork_mode] [||||| ] 74.426 MB ● oc-server [ ] 0 %[3] [fork_mode] [|||| ] 57.801 MB ● pm2-http-interface [ ] stopped[4] [fork_mode] [ ] 0 B ● start-production[5] [fork_mode] 内存使用超过上限自动重启如果想要你的应用，在超过使用内存上限后自动重启，那么可以加上--max-memory-restart参数。（有对应的配置项）1pm2 start big-array.js --max-memory-restart 20M 更新pm2官方文档：http://pm2.keymetrics.io/docs/usage/update-pm2/#updating-pm2123$ pm2 save # 记得保存进程状态$ npm install pm2 -g$ pm2 update pm2 + nginx无非就是在nginx上做个反向代理配置，直接贴配置。12345678910111213141516171819202122upstream my_nodejs_upstream { server 127.0.0.1:3001;}server { listen 80; server_name my_nodejs_server; root /home/www/project_root; location / { proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-NginX-Proxy true; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_max_temp_file_size 0; proxy_pass http://my_nodejs_upstream/; proxy_redirect off; proxy_read_timeout 240s; }} 官方文档：http://pm2.keymetrics.io/docs/tutorials/pm2-nginx-production-setup 在线监控系统收费服务，使用超级简单，可以方便的对进程的服务情况进行监控。可以试用下，地址在这里。 这里贴个项目中试用的截图。 pm2编程接口如果想把pm2的进程监控，跟其他自动化流程整合起来，pm2的编程接口就很有用了。细节可参考官方文档：http://pm2.keymetrics.io/docs/usage/pm2-api/ 模块扩展系统pm2支持第三方扩展，比如常用的log rotate等。可参考官方文档。","link":"/2018/11/22/PM2实用入门指南/"},{"title":"CentOS7安装Node环境","text":"CentOS下安装Node1234567891011121314# 1、获取资源cd /usr/local/srcwget https://npm.taobao.org/mirrors/node/v10.13.0/node-v10.13.0.tar.gz# 2、解压tar xvf node-v10.13.0.tar.gz# 3、进入解压后node文件夹开始编译cd node-v10.13.0/./configuremake# 4、安装Nodemake install# 5、验证是否正确安装node -v 注意： 第3步编译过程中若报错：C++ Compiler too old, need g++ 4.9.4 or clang++ 3.4.2 (CXX=g++)，那需要先升级一下 gcc，编译正常的话请忽略直接跳至第五步开始安装,通过gcc -v查看版本 安装PM21234# 安装npm install pm2 -g# 查看安装后版本pm2 -v","link":"/2019/01/28/centOS7安装Node环境/"},{"title":"docker入门","text":"Docker是一个使用Go语言开发的开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的机器上。什么是Docker?一个用来装应用的窗口，","link":"/2019/02/02/docker入门/"},{"title":"nodemon-解决开发时无限npm start的痛点","text":"刚开始学习Node时，每次做了修改，都要重新npm start启动服务才能查看上次修改结果，而nodemon就是为了开发node时进行热更新的一款工具 目录 -安装-配置nodemon 安装 先全局安装，再以开发依赖形式安装 1234# 全局安装npm install nodemon -g# 依赖安装npm install nodemon -D 配置nodemon 新建nodemon.json文件默认为nodemon的配置文件，从而进行自定义启动配置 也可以直接在package.json中新增nodemonConfig字段进行配置 123456789101112131415{ \"restartable\":\"rs\", \"verbose\": true, \"ignore\":[ \".git\", \".svn\", \"node_modules/**/node_modules\" ], \"execMap\": { \"js\": \"node --harmony\" }, \"env\":{ \"NODE_ENV\": \"development\" }} 配置项说明：属性|说明—|—restartable|设置重启模式verbose|设置日志输出模式，true为详细模式ignore|设置忽略文件execMap|设置运行服务的后缀名与对应的命令watch|监听哪些文件的变化，当变化时行动重启ext|监控指定的后缀文件名 123\"execMap\":{ \"js\":\"node -harmony\"} 表示使用nodemon代替node 启动服务 nodemon ‘./bin/www.js'","link":"/2017/10/25/nodemon/"},{"title":"Nginx+PM2+node简单配置","text":"记录一些常用的简单Nginx配置，如：反向代理、负载均衡、HTTPS配置、解决跨域问题等 一个最简单的反向代理配置方式12345678server { listen 80; server_name www.kingdou.fun; location / { proxy_pass http://127.0.0.1:3000; }} 使用PM2永动机启动Node.js项目，再使用nginx做反向代理，简直完美。 因为node.js程序监听的是服务器端口，使用nginx做反向代理，就可以任意配置你的二级域名来访问你的程序 简单的负载均衡配置方式123456upstream b.com { ip_hash; server 192.168.5.150:80; server 192.168.5.151:80; server 192.168.5.151:8080; } 简单的Https配置123456789101112131415161718server{ listen 443 ssl; server_name xxx.xxx.com; ssl_certificate /root/certs/test.crt; ssl_certificate_key /root/certs/test.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location /{ proxy_pass http://localhost:3000; proxy_set_header Host $host; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_read_timeout 86400; }} Nginx解决跨域问题1234567891011121314server{ listen 80; server_name test.abc.com; location / { proxy_pass http://127.0.0.1:8080; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Headers Content-Type; add_header Access-Control-Allow-Methods POST; add_header Access-Control-Allow-Methods GET; }}","link":"/2019/02/15/nginx与pm2常用配置/"},{"title":"MarkDown语法汇总","text":"本文主要记录Markdown相关编写语法以及Hexo博客编写语法 文章头部123456789101112---title: 标题date: 时间banner: 首页展示bannerthumbnail: images/deer.jpg # 注意此本地图片目录结构为 source/images/deer.jpg，不要放到主题下的images中去tag: 标签 categories: 分类# 阅读更多的标记&lt;!--more--&gt; --- 段落语法 这是一个段落呀 自定义目录 1.1 1.2 123[标题一](#目录跳转标题)- [1.1](#功能快捷键)- [1.2](#新的改变) 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 123456*强调文本* _强调文本_**加粗文本** __加粗文本__==标记文本==~~删除文本~~&gt; 引用文本 插入链接与图片链接: Sophie’s World. 图片: 带尺寸的图片: 123链接: [Sophie&apos;s World](https://sophieu.github.io/SophieU/).图片: ![Alt](http://tylingsoft.com/img/mdm/icon.png)带尺寸的图片: &lt;img src=&quot;http://tylingsoft.com/img/mdm/icon.png&quot; width=&quot;20px&quot; height=&quot;20px&quot;/&gt; 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片 12// An highlighted blockvar foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的： 项目 Value 电脑 $1600 手机 $12 导管 $1 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 创建一个自定义列表 目录1 缩进一 缩进二 123* 目录1 + 缩进一 + 缩进二 如何创建一个注脚一个具有注脚的文本。^2","link":"/2018/09/25/站点简介/"},{"title":"vue与react详细对比","text":"每次用vue或者react做完一个项目，隔个两三个月不用vue或react时，会发现要么好多东西又忘了，要么很多API混在一起了。所以，写下这篇文章，用于以后不时的复习参考。同时也加深下对两个框架的认知。 目录 Vue与React 介绍 区别 VueRouter与ReactRouter Vuex与Redux Vue与React服务端渲染 Vue与React的代码拆分 Vue与React 对比项 Vue React 路由管理 VueRouter React-Router 状态管理 Vuex Redux 动画过度 &lt;Transition&gt; react-transition-group 介绍 Vue.js是什么？？ Vue是一套用于构建用户界面的渐进式框架。【vue与其他框架对比】 React.js是什么?? -React是一个用于构建用户界面的 JavaScript 库。区别 JSX与Template 在React中一切皆为JS，所以对于HTML的书写，引入了JSX的概念，JSX等同于用React.createElement 12345678910// react class MyComponent extends React.Component{ render(){ return (&lt;div&gt;hello,react&lt;/div&gt;) }}// vue&lt;template&gt; &lt;div&gt;hello, vue&lt;/div&gt;&lt;/template&gt; CSS写法 React中可以使用行类样式（不推荐），也可以使用CSS-in-JS,也可以通过import导入样式文件的方式来引用CSS。Vue则直接在Style标签中 123456// reactimport './mycomponent.css'// vue&lt;style scoped&gt; div{background:'#eee';}&lt;/style&gt; React.createElement与VueRender 二者都可以手动渲染对应组件。createElement、Render 123456789// reactReact.createElement({ type, //'div' [props], // {className:'hello'} [...children] , //'内容'})render: function (createElement) { return createElement('p', 'No items found.')} vue的data和react的state 它们都是用于维护组件作用域内的数据 123456789101112131415// reactconstructor(){ super(); this.state={name:'haha'} }componentDidMount(){ this.setState({name:'lala'})}//vuedata:{ name:'vue'}mounted(){ this.name='vueTop'} 事件绑定 123456789101112// reactconstructor(){ super(); this.handleClick=this.handleClick.bind(this);}&lt;button onClick={this.handleClick}&gt;点我&lt;/button&gt;// vuemethods:{ handleClick(){//...} }// 或者@click&lt;button v-on:click={this.handleClick}&gt;点我&lt;/button&gt; 表单数据 vue中通过v-model实现双向绑定，react中通过value与onChange事件监听实现受控组件 1234// react&lt;input value={this.state.name} onChange={()=&gt;this.inputChange}/&gt;// vue&lt;input v-model={this.name} /&gt; 插槽 vue中使用slot来实现子元素内容的渲染，react通过props.children 123456789101112// react&lt;div&gt; &lt;h3&gt;父标题&lt;/h3&gt; {props.children}&lt;/div&gt;//vue&lt;div&gt; &lt;h3&gt;父标题&lt;/h3&gt; &lt;template slot=\"child\"&gt;&lt;/template&gt;&lt;/div&gt;// 对应child中定义slot&lt;slot name=\"child\"&gt;&lt;/slot&gt; VueRouter与ReactRouter VueRouter文档 ReactRouter文档V4.3.x Vue Router是Vue.js官方的路由管理器， 示例：React简单使用12345678910111213// react-routerimport {BrowserRouter as Router,Switch, Route, Link} from 'react-router-dom';const Index = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;const AppRouter=()=&gt;( &lt;Router&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Switch&gt; &lt;Route path=\"/\" exact component={Index}/&gt; &lt;/Switch&gt; &lt;/Router&gt;) vue-router简单使用1234567891011121314151617// vueconst Home = { template: '&lt;p&gt;home page&lt;/p&gt;' }const About = { template: '&lt;p&gt;about page&lt;/p&gt;' }// 创建路由对象const routes = { '/': Home, '/about': About}const router = new VueRouter({ routes})// 引入到实例中const app = new Vue({ router}).$mount('#app')// 跳转链接 &lt;router-link to=\"/foo\"&gt;Go to Foo&lt;/router-link&gt; 使用时的不同点总结： vue-router是全局配置方式，react-router是全局组件方式。 vue-router仅支持对象形式的配置，react-router支持对象形式和JSX语法的组件形式配置。 vue-router任何路由组件都会被渲染到位置，react-router子组件作为children被传入父组件，而根组件被渲染到位置。 路由懒加载123456789// vue-router : 通过在component处使用动态importconst routes = [ {{ path: '/foo', component: ()=&gt; import(\"@/component/foo\") },}]// react : 使用react.lazy()const Foo = React.lazy(()=&gt;import(\"./component/foo\"))&lt;Router&gt; &lt;Route exact path=\"/foo\" component={Foo}/&gt;&lt;/Router&gt;","link":"/2018/12/04/vue与react详细对比/"},{"title":"vue打包优化","text":"通常在使用Vue开发单面应用时，由于第三方库大都是在main.js中进行引用的，而webpack在打包时，会将所引用的第三方库都打包到vendor.js中，导致vendor.js过大。针对这个问题可以进行以下优化： 优化方案 使用CDN引用第三方库 vue-router懒加载 CDN引用 可以使用的CDN很多，例如： unpkg就是全球好用的CDN12// https://unpkg.com/包名@version/ ,不加@version的话，则是默认最新版本&lt;script src=\"https://unpkg.com/vue@2.5.2/dist/vue.min.js\"&gt;&lt;/script&gt; 例： 将vue和iview以CDN的方式引用到项目中 步骤一:引用CDN12345&lt;script src=\"https://unpkg.com/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境，改用vue.min.js --&gt;&lt;!--&lt;script src=\"https://unpkg.com/vue@2.5.2/dist/vue.min.js\"&gt;&lt;/script&gt;--&gt;&lt;script src=\"https://unpkg.com/iview/dist/iview.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/echarts/4.2.0-rc.1/echarts.common.min.js\"&gt;&lt;/script&gt; 在引用后，默认Vue，iview是全局变量可以直接拿到，针对iview的一些修改，可以直接用iview变量 注意： iview使用CDN方式时，其Form组件应使用i-form，而&lt;FormItem&gt;对应&lt;form-item&gt; 例：调用iview的loadingBar,iview.loadingBar.start() 步骤二：修改webpack12345678910// webpack.base.conf.jsmodule.exports={ //.... externals:{ 'vue':'Vue', 'iview':'iView', 'echarts':'echarts' }, //...} vue-router懒加载 通常我们在写router时，时以下方式 123456import Hello from '@/components/Hello.vue'export const router=[{ path:'/', name:'home', component:Hello}] 这种方式会将所有组件都打包在一些，导致打包文件很大。 改进12345export const router=[{ path:'/', name:'home', component:()=&gt;import('@/components/Hello.vue')}] 通过vue-router懒加载，你会发现打包后，会有很多js文件生成，这些都是对应不同组件，当匹配到某路由时，才会加载对应js","link":"/2018/01/10/vue打包优化/"},{"title":"ReactRedux教程及文档要点","text":"Redux 是 JavaScript 状态容器，提供可预测化的状态管理。它以让你构建一致化的应用，运行于不同的环境（客户端、服务器、原生应用），并且易于测试。参考文档：Redux中文文档，官方文档 Redux 除了和 React 一起用外，还支持其它界面库。 它体小精悍（只有2kB，包括依赖）。实际上，你并不一定需要使用到Redux,参考文章: “You Might Not Need Redux” 目录 安装 核心要点 Action Reducer Store 搭配React使用 安装 多数多数情况下，你除了安装redux外，还需要使用 React 绑定库和开发者工具。1234$ yarn add redux# 安装react绑定库及开发工具$ yarn add react-redux $ yarn add redux-devtools --dev 核心要点 Redux是将整个应用状态存储到一个叫store的对象上,里面保存着一个状态树store tree,整个app内部的组件都订阅了store中的状态state来对应自己的视图，用户产生action传递给store，store找到对应reducer来处理此行为action，并返回新的state到store中，从而影响了订阅store的组件的视图。 组件产生行为：Component-dispatch-action store为action找到对应处理函数reducer reducer返回新的state到store 因为组件订阅了store,所以当store发生变化时，组件视图也会发生相应变化。 组件可以派发(dispatch)用户的行为(action)给store,而不是直接通知其他组件，组件内部通过订阅store中的状态state来刷新自己的视图。 Redux工作流： redux三大原则 唯一数据源：整个应用的state都被存储在一个状态树中，而这个状态树由store对象管理 操持只读状态：state是只读的，唯一改变state的方法就是触发action，action是一个用于描述以发生时间的普通对象 数据改变只能通过纯函数来执行 : 使用纯函数(reducer)来执行修改，为了对action做出响应并改变对应state，你需要编写reducers 关键词 store ： 全局state树，视图的更新都依赖于store action:把数据从应用传到store的JS对象，通过store.dispatch()将action传到store，通常用一个单独的js来传递应用中的action。 reducer ： 根据不同的action做出相应处理并返回新的state 以下是一个不规范的简单使用redux示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/* store.js 统一的state管理*/import {createStore} from 'redux';// reducerfunction counter(state=0,action){ switch(action.type){ case 'INCREMENT': return state +1; case 'DECREMENT': return state -1; default: return state }}let store = createStore(counter);//actionsexport const INCREMENT={type:'INCREMENT'};export const DECREMENT = {type:'DECREMENT'};export default store;/*Component.js*/import React from 'react';import store,{INCREMENT,DECREMENT} from './redux/index'// 通过 store.getState()取值，这里目前只考虑了只有一个state的情况function Component (props){ return ( &lt;Router&gt; &lt;div&gt; &lt;div&gt;这是counter: {store.getState()}&lt;/div&gt; &lt;div&gt; &lt;button onClick={()=&gt;store.dispatch(INCREMENT)}&gt;加&lt;/button&gt; &lt;button onClick={()=&gt;store.dispatch(DECREMENT)}&gt;减&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/Router&gt; )}export default Component;/*index.js ：统一渲染的index.js*/import React from 'react';import ReactDOM from 'react-dom';import Component from './Component';import store from './redux/index';//首次渲染ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));// 通过store.subscribe订阅store，才能让store中的state变化时能及时更新到视图上store.subscribe(function(){ ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));}); 总结： action通常长这样儿：{type:'INCREMENT'}，通常type对应的是一串大写的字符串 通过createStore(reducer)来创建store对象,这样就能把reducer中对应的state传入到store中来统一管理 通过state.getState()来获取state的值，通过store.subscribe(fn)来订阅store，传入reactDOM.render即为更新视图 通过store.dispatch(action)来向store传递action，从而改变对应的state Action Action 是把数据从应用传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。本质为一个普通的JS对象。 我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。import { ADD_TODO, REMOVE_TODO } from '../actionTypes' Action的创建有以下几种方式： 定义JS对象的方式：{type:'ADD'} 通过创建函数来创建12345678910111213141516171819202122232425262728// 如下就是一个单独的action.js文件的常见内容/* * action 类型 */export const ADD_TODO = 'ADD_TODO';export const TOGGLE_TODO = 'TOGGLE_TODO'export const SET_VISIBILITY_FILTER = 'SET_VISIBILITY_FILTER'/* * 其它的常量 */export const VisibilityFilters = { SHOW_ALL: 'SHOW_ALL', SHOW_COMPLETED: 'SHOW_COMPLETED', SHOW_ACTIVE: 'SHOW_ACTIVE'}/* * action 创建函数 */export function addTodo(text) { return { type: ADD_TODO, text }}export function toggleTodo(index) { return { type: TOGGLE_TODO, index }}export function setVisibilityFilter(filter) { return { type: SET_VISIBILITY_FILTER, filter }} ReducerReducers指定了应用状态的变化如何响应 actions 并发送到 store 的，记住 actions 只是描述了有事情发生了这一事实，并没有描述应用如何更新 state。 reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。 永远不要在reducer内部做以下事： 修改传入参数： 执行有副作用的操作，如API请求和路由跳转 调用非纯函数，如Date.now()或Math.random(); 以下是TODO示例中reducers.js的代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import {combineReducers} from 'redux';import{ ADD_TODO, TOGO_TODO, SET_VISIBILITY_FILTER, Visibility,} from \"./actions\";const {SHOW_ALL} = Visibility;function visibilityFilter(state=SHOW_ALL,action){ switch (action.type) { case SET_VISIBILITY_FILTER: return action.filter; default: return state }}function todos(state=[],action){ switch(action.type){ case ADD_TODO: return [ ...state, { text:action.text, completed:false } ] case TOGO_TODO: return state.map((todo,index)=&gt;{ if(index===action.index){ return Object.assign({},todo,{ completed: !todo.completed }) } return todo }); default: return state; }}const todoApp = combineReducers({ todos, visibilityFilter});export default todoApp; 总结： 通过combineReducers来将多个单一的reducer整合在一起导出 reducer是纯函数 reducer的函数名其实就对应了最后store.getState()得到的state的各个属性 通过(state=xxx,action)可以设置reducer对应的state的默认值。 Storestore就是把action和reducers联系在一起的总的state 树对象。它的职责如下： 给的应用的state; 提供getState()方法用于获取state; 提供dispatch(action)方法用于更新state; 通过subscribe(listenerFunc)注册监听器用于监听state的变化，其中的函数会在state发生变化时调用 subscribe(listenerFunc)的返回值就是一个函数注销监听器。 示例：一个TODO应用中的store.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// store.jsimport {createStore} from 'redux';import todoApp from './reducers';let store = new createStore(todoApp);export default store;// index.jsimport store from './redux/store';store.subscribe(()=&gt;{ ReactDOM.render(&lt;App /&gt;, document.getElementById('root'))});// App.jsimport React from 'react';import store from './redux/store';import {addTodo,toggleTodo,setVisibilityFilter} from './redux/actions';class App extends React.Component{ constructor(){ super(); this.addInput=React.createRef(); } addTodo=()=&gt;{ let addInput = this.addInput.current; let todoText = addInput.value; store.dispatch(addTodo(todoText)); addInput.value=''; }; toggleTodo=(e)=&gt;{ let index = parseInt(e.target.dataset.index); store.dispatch(toggleTodo(index)); console.log(index) console.log(typeof index) }; toggleVisible=(e)=&gt;{ let visible = e.target.dataset.visible; store.dispatch(setVisibilityFilter(visible)); }; render(){ let state = store.getState(); let todos = state.todos; let visibilityFilter = state.visibilityFilter; console.log(state) return ( &lt;div&gt; &lt;input ref={this.addInput} type=\"text\" className=\"input-todo\"/&gt; &lt;button onClick={this.addTodo}&gt;add TODO&lt;/button&gt; &lt;ul className=\"todo-list\"&gt; { todos.map((todo,index)=&gt;{ return (&lt;li key={index} data-index={index} onClick={this.toggleTodo} className={todo.completed?'finished':''}&gt;{todo.text}&lt;/li&gt;) }) } &lt;/ul&gt; &lt;div className=\"toggle-todo\"&gt; &lt;span data-visible=\"SHOW_ALL\" onClick={this.toggleVisible} className={visibilityFilter==='SHOW_ALL'?'active':''}&gt;显示全部&lt;/span&gt; &lt;span data-visible=\"SHOW_COMPLETED\" onClick={this.toggleVisible} className={visibilityFilter==='SHOW_COMPLETED'?'active':''}&gt;已完成&lt;/span&gt; &lt;span data-visible=\"SHOW_ACTIVE\" onClick={this.toggleVisible} className={visibilityFilter==='SHOW_ACTIVE'?'active':''}&gt;未完成&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; ) }}export default App; 以上结合action.js,reducer.js,store.js等就构成了一个完整的TODO应用。总结 通过createStore(reducers,defaultValue)来创建一个store,其中参数defaultValue是可选的，用于设置 state 初始状态。【这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。】 在组件中，通过store.getState()来获取整个state 通过store.dispatch(action)来发起action 搭配React使用Redux 和 React 之间没有关系。Redux 支持 React、Angular、Ember、jQuery 甚至纯 JavaScript。只是说，Redux与React搭配也是很好用的。 安装 redux默认并不包含React 绑定库,因此要同时安装redux和react-redux 可以通过yarn add react-redux安装，也可以通过npm，还可以从unpkg获取最新的UMD包（包括开发环境包和生产环境包）。 通过&lt;script&gt;引入UMD包会在全局抛出window.ReactRedux对象。1$ yarn add react-redux 关键词 &lt;Provider/&gt;：通常用于包裹App组件。用于外层包裹组件，通过设置属性store=store,来将store关联到整体组件中 connect : 用于各react子组件内部，通过connect(mapStateToProps,mapDispatchToProps)(Component)例各子组件与 store建立联系 mapStateToProps : 【字面理解】-将State映射到组件Props中，从而可以直接使用this.props.xxx来直接访问store中的state mapDispatchToProps : 【字面理解】-将Dispatch映射到组件Props中，从而可以直接使用this.props.dispatch(action)来达到store.dispatch的同等效果。 对上面的TODO进行改造123456789101112131415161718192021222324252627282930313233343536373839404142// index.js中，去掉store.subscribe()而使用Provider组件ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root'));// App.js // App组件中的代码段toggleVisible=(e)=&gt;{ let visible = e.target.dataset.visible; this.props.setVisibilityFilter(visible);}; render(){ let todos = this.props.todos; let visibilityFilter = this.props.visibilityFilter; return(/*....*/) }// mapStateToProps,mapDispatchToProps是自己手动映射props的函数const mapStateToProps = state=&gt;{ return { todos:state.todos, visibilityFilter:state.visibilityFilter, }};const mapDispatchToProps = dispatch=&gt;{ return { toggleTodo:index=&gt;{ dispatch(toggleTodo(index)) }, addTodo:text=&gt;{ dispatch(addTodo(text)) }, setVisibilityFilter:filter=&gt;{ dispatch(setVisibilityFilter(filter)) } }}const AppStore = connect(mapStateToProps,mapDispatchToProps)(App)export default AppStore; 和ReactRouter搭配使用 参考使用这个库：connected-react-router，原react-router-redux作者已经不再维护了。 一些中间件 redux-saga: 一个用来处理异步任务的redux中间件。 在 reducers 中的所有操作都是同步的并且是纯粹的，即 reducer 都是纯函数，纯函数是指一个函数的返回结果只依赖于它的参数，并且在执行过程中不会对外部产生副作用，即给它传什么，就吐出什么。但是在实际的应用开发中，我们希望做一些异步的（如Ajax请求）且不纯粹的操作（如改变外部的状态），这些在函数式编程范式中被称为“副作用”。 而redux-saga就是用来做这些异步操作的 redux-thunk:也是一个异步中间件，是redux作者写的。特点：action可以是一个以dispatch为参数的函数，在函数内部做异步操作。缺点：要redux本身的action为对象的概念冲突，导致类型不统一","link":"/2017/12/11/ReactRedux教程及文档要点/"},{"title":"MySQL入门教程","text":"MySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。参考学习：菜鸟教程-mysql MySQL特点 MySQL 是开源的，所以你不需要支付额外的费用； MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL 使用标准的 SQL 数据语言形式。 MySQL 可以运行于多个系统上，并且支持多种语言。【这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。】 MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。。MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。 目录 安装 MySQL管理 数据库操作 表操作 记录操作 常用的数据类型 字段属性 总结 安装所有平台的 MySQL 下载地址为： MySQL 下载 。 挑选你需要的 MySQL Community Server 版本及对应的平台。 注意：安装过程我们需要通过开启管理员权限来安装，否则会由于权限不足导致无法安装。 Windows平台下安装1、下载 windows下载地址：https://dev.mysql.com/downloads/mysql/ 下载完后，我们将 zip 包解压到相应的目录，这里我将解压后的文件夹放在 F:\\Program Files\\mysql-8.0.11 下。 2、新建配置文件在刚刚解压的目录位置新建my.ini 配置文件，编辑 my.ini 配置以下基本信息：1234567891011121314151617[mysql]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=F:\\Program Files\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\web\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 3、初次启动下 MySQL 数据库：1234# 以管理员身份打开 cmd 命令行工具，切换目录到mysql安装目录下的bin目录cd F:\\Program Files\\mysql-8.0.13&gt;bin# 初始化数据库mysqld --initialize --console 执行完成后，会输出 root 用户的初始默认密码，其中：APWCY5ws&amp;hjQ就是初始密码，后续登录需要用到，你也可以在登陆后修改密码。12016-08-25T02:35:05.464644Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: APWCY5ws&amp;hjQ 将mysql安装为windows服务123456789# 还是在bin目录下mysqld install# 启动mysqlnet start mysql# 提示F:\\Program Files\\mysql-8.0.13\\bin&gt;net start mysqlMySQL 服务正在启动 ...MySQL 服务已经启动成功。 4、登录 MySQL当 MySQL 服务已经运行时, 我们可以通过 MySQL 自带的客户端工具登录到 MySQL 数据库中, 首先打开命令提示符, 输入以下格式的命名: 12345# 命令：mysql -h 主机名 -u 用户名 -p# 如果我们要登录本机的 MySQL 数据库，只需要输入以下命令即可：回车后输入初始密码mysql -u root -p 参数说明：-h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0。1)该参数可以省略;-u : 登录的用户名;-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。 若密码存在, 输入密码登录, 不存在则直接按回车登录。登录成功后你将会看到 Welecome to the MySQL monitor… 的提示语。然后命令提示符会一直以 mysq&gt; 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。 MySQL管理windows下启动与关闭12345678# 启动 mysql安装目录下bin目录mysqld --console# 关闭 cd c:/mysql/binmysqladmin -uroot shutdown# windows服务的启动关闭net start mysqlnet stop mysql 重置初始密码 在首次进入mysql命令工具中时，任何操作它都会提示：You must reset your password using ALTER USER statement before executing this statement.表示 需要先重置初始密码123456789# 更新密码mysql&gt; alter user root@localhost identified by '123456';# 刷新权限mysql&gt; flush privileges;# 退出exit;# 重登录mysql -u root -ppassword: ****** MySQL 基础指令 服务器、数据库、数据表、记录、字段的关系： 一台mysql服务器可以管理多个数据库！一个数据库存在多张二维表！一张表存在多条记录（行）！一条记录由多个字段组成！字段，才是最终的元数据！ 因此，如果需要完成对数据的操作： Step1. 连接数据服务器 Step2. 管理某个数据库 Step3. 操作某个表的具体数据 关键词 show: 显示数据库、表 create: 创建数据库、表 drop:删除数据库、表 alter:修改数据库、表 将SQL操作的目标不同，分成不同的语言：SQL = DDL + DML。 DDL，数据定义语言！数据结构的操作（操作库和操作表） create，drop，show，alter alter table add column， drop column，change column，modify column DML，数据的管理语言 数据的操作： Insert（增）， delete（删），update（改），select（查） 数据库操作 注意：每一条mysql命令都必须以分号结束; 创建数据库语法： create database 数据名 [数据库选项] 1234# 普通创建create database test# 更优的创建create database `test2` 注意数据库名的处理： 有些词语是mysql的关键字或者保留字，此时可以使用 反引号将库名（库标识符）进行包裹！ 建议，所有的标识符，都应该加上反引号！尤其在使用字符串拼凑SQL的时候！此时，当使用了反引号后，几乎所有的字符串都可以作为名字出现： 查询数据库 语法： show databases (支持使用like 对展示的结果进行过滤：show databases like 'match') 注意此处的databases复数 1234# 显示所有数据库show databases;# 筛选show databases like 'test'; like后面使用字符串作为过滤原则。mysql中的字符串，使用单引号进行包裹！（也是支持双引号，但是双引号有特别的含义，因此不建议使用） 字符串中可以使用 通配符！（通用匹配符号）% 百分号，匹配任意字符的任意数量;_ 下划线，匹配任意字符的一次出现！ 切换到某一数据库 语法： use [库名]1234567&gt;mysql use test;+----------------+| Tables_in_test |+----------------+| user |+----------------+1 row in set (0.03 sec) 删除数据库 语法：drop database 库名修改数据库选项（了解） 语法：alter database 库名 表选项容错命令在创建和删除数据库时，可以通过容错命令来判断是否进行 if not exists 如果不存在，用在创建时，表示，如果不存在该库时才创建！ if exists 如果存在，删除时使用，表示如果存在，才执行删除工作 注意：数据库名是严格区分大小写的1234# 新增create database if not exists test2;# 删除drop database if exists test; 表操作创建表（重要） 数据保存在字段中，mysql每个字段都要有类型，属于强类型！需要指定字段的名称和类型： 典型的类型：int整型，varchar(M)变长字符串类型，其中M表示最大长度，字符数！典型的表选项：engine 引擎，表示表的存储类型，常见的有： myisam,innodb,charset 字符集 在创建表时，需要指定表所在的数据库：可以在表名上直接指定：完整表名由 组成！12345678910111213- 同样支持：if not exists。- 语法： ```bashcreate table 表名 (表中字段信息）[表选项]# 应用mysql&gt; create table test.students( -&gt; name varchar(20), -&gt; age int, -&gt; gender varchar(10) -&gt; ); 每个表，会在当前的库目录下，生成其所需要的文件，都是以表名为文件名，后缀不同的文件组成： 注意：表名如果与关键字冲突，也需要使用反引号.因此：注意需要将库名与表名独立包裹： match.order 数据库文件: 在mysql安装目录下，data文件夹便存放着创建的数据库，如 mysql\\data\\test 代表test数据库的文件； 其中：.frm保存的当前表的结构文件！ 注意：不是所有的表生成的文件都是一样的的，取决于表的类型（引擎），引擎不同数据库服务器管理表库数据的结构是不同的，意味着操作不是完全相同！12create table itsource.t1_myisam(id int) engine=myisam;create table itsource.t2_innodb(id int) engine=innodb; 其中： 对于myisam：.frm结构；.myd数据；.myi索引！对于innodb：.frm结构；数据和索引在其他的文件： 查看表 语法：show tables [like '表名'] 查看建表语句,语法： show create table 表名 查看表结构，语法：desc 表名123mysql&gt; show tables like user;mysql&gt; show create table user;mysql&gt; desc user; 删除表语法：drop table [if exists] 表名 修改表 修改表选项——语法：alter table 表名 选项=新值 重命名表——语法：rename table 旧表名 to 新表名(如果采用 库名.表名的修改语法，导致将A库表，移动到B库中！) 添加字段——语法：alter table 表名 add column 字段定义 位置 删除字段——语法：alter table 表名 drop column 字段名 修改并重新定义字段： 语法：alter table 表名 change column 旧字段名 新字段定义（名字，类型，属性） 位置 字段只修改定义： 语法：alter table 表名 modify column 字段名 新的定义(类型，属性)1234567891011121314# 修改选项alter table test engine=innodb;# 重命名rename table user to newuser;# 移动rename table test.user to sys.user;# 添加字段alter table newuser add column job varchar(10) after name;# 删除字段 alter table newuser drop column job;# 修改并重新定义alter table newuser change column age userage varchar first;# 只修改字段定义alter table newusr modify column userage int after name; 记录操作增加 语法：insert into 表名 (字段列表) values (值列表) 其中，可以省略字段名列表部分，前提是，字段值必须要一一对应。（数量和顺序都一致） 标准写法：将字段名使用反引号 包裹！1234# 完整写法insert into user(name,age,gender) values('ming',18,'man');# 简单写法insert into user values('hong',17,'woman'); 查询 语法 select 字段列表 from 表名 [where 条件表达式] 字段列表，应该使用逗号分隔的一个个的字段名。特别的使用*表示所有字段！条件可以被省略，表示默认成立，意味着会检索到所有数据！ 注意：条件表达式，是指所有可以获得值的语句！ 在mysql中的sql，关系表达式返回的是0或者1，mysql没有布尔型数据，其中1表示真，0表示假！12345678910111213141516171819202122232425262728# 查询所有数据mysql&gt; select * from users;+--------+------+--------+| name | age | gender |+--------+------+--------+| sophie | 18 | woman || ju | 19 | man |+--------+------+--------+2 rows in set (0.00 sec)# 查询单个字段 mysql&gt; select age from users;+------+| age |+------+| 18 || 19 |+------+2 rows in set (0.00 sec)# 筛选mysql&gt; select * from users where gender='woman';+--------+------+--------+| name | age | gender |+--------+------+--------+| sophie | 18 | woman |+--------+------+--------+1 row in set (0.00 sec) 删除 delete 语法：delete from 表名 [where 条件] 有where子句时，删除匹配的记录。没有where子句则删除该表所有数据。 注意 =（等于） 在mysql的sql中是关系运算符！123# 删除name='ju';mysql&gt; delete from users where name='ju';Query OK, 1 row affected (0.42 sec) 修改 语法：update 表名 set 字段=值, 字段=值 [where 条件表达式];1234567891011121314# 修改mysql&gt; update users set age=20 where name='la';Query OK, 1 row affected (0.51 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from users;+--------+------+--------+| name | age | gender |+--------+------+--------+| sophie | 18 | woman || la | 20 | man || haha | 17 | woman |+--------+------+--------+3 rows in set (0.00 sec) 常用的数据类型 数字型、字符串型、日期时间型、其他。（MySQL的数据类型主要分为三大类型：数字型、字符串型、日期时间型。）数字型 整型：int。有不同长度的整型，默认是4个字节， 小数型：float：单精度，占4字节，存储数小,double：双精度，占8字节，数很大。【所有浮点数，保存的都是近似值，而不是精确值，不能拿浮点数做精确比较】【在定义浮点数时，需要指明有效数位,小数数位】 字符串类型： char(M)定长字符串M为最大字符数，varchar(M)可变字符串M为最大字符串。 文本内容text： 日期时间： datetime: 典型格式YYYY-MM-DD HH：II：SS timestamp:时间戳，节省资源，范围在1970-2038年 如何选择数据类型？在能够满足功能的前提下，尽量使用占用空间小或者计算容易的！ 字段属性 null属性：表示是否允许值为空（null可以为空，not null不允许为空）[注：默认是允许为空，当没有写 null或者not null 相当于null！] 1234create table test( allow_null int null, not_allow int not null); default属性：当为记录增加数据时，如果没有指定字段的值，Mysql会使用该字段的默认值来填充该字段！ 特殊的关键字：current_timestamp，在定义时间戳类型的字段上使用，表示，该字段的默认值为当前时间戳！ 1234create table test( name varchar(10) default 'zhangsan', times1 timestamp default current_timestamp); primary key主键：要求建立在列字段的值都是唯一的值！在该字段上，建立一个要求，要求在插入数据（更新）对，字段的唯一性做检查，在语法上严格规定，某个字段内的所有值，不能重复！【如果字段的值是唯一的，那么就可以使用该字段，来唯一地确定当前表内的某个记录！】 auto_increment自动增长，每当增加一个条记录，自动生成一个序列号！自动增长依赖于主键！如果一个字段是主键，可以将其定义成整型，并设置自动增长的属性，这样可以为该字段生成不重复的唯一的ID标识！12345create table test2( id int primary key auto_increment, name varchar(10) not null, age int default 10); 总结 在windows下操作mysql可以使用Navicat图形化操作工具 常用数据库操作 12345678910111213141516171819202122232425数据表操作：create table student(id int primary key auto_increment,name varchar(10),gender char(2))engine=myisam;show tables;desc student;drop table student;alter table student change column name username varchar(20) after id;记录操作：insert into student(id,username,gender) values (1,&apos;刘备&apos;,&apos;男&apos;);insert into student(id,username,gender) values (2,&apos;张飞&apos;,&apos;男&apos;);select * from studentselect * from student where username=&apos;刘备&apos;;select * from student where id &gt;1;update student set gender=&apos;女&apos; where username=&apos;张飞&apos;;update student set username=&apos;花木兰&apos; where id=2;delete from student where id=2;delete from student;","link":"/2017/08/07/Mysql入门/"},{"title":"React进阶要点汇总(一)","text":"入门React后，基本上可以写一个小型项目了，但React还有很多高级功能及API可以上手方便开发。以下便是React进阶教程说明。 目录 代码拆分 错误处理ErrorBoundaries 上下文Context Refs 片段Fragment 代码拆分 类似于vue中的组件引用时加载，react也可以在引用时再加载到组件中，从而使打包的app.js被拆分为多个组件。 代码拆分的方法有多种，如：CodeSpliting打包优化，react.lazy懒加载，基于路由进行代码拆分 代码拆分可以提升首屏加载速度 CodeSpliting 将代码拆分引入到应用程序中的最好方法是通过动态 import() 语法。在create-react-app中已经配置好对应的webpack语法，Next.js也支持开箱即用，而如果自己设置webpack话，需要阅读关于code spliting的代码拆分指南babel对应解析动态导入语法：babel-plugin-syntax-dynamic-import 示例：create-react-app动态import12345678910111213141516171819202122232425262728293031// asyncComponent.js 创建一个动态导入组件函数export default function asyncComponent(importComponent){ class AsyncComponent extends Component{ constructor(props){ super(props); this.state={ component:null } } async componentDidMount(){ const {default:component} = await importComponent(); this.setState({ component:component }) } render(){ const C = this.state.component; return C?&lt;C {...this.props}/&gt;:null } } return AsyncComponent;}// 在create-react-app中使用 动态importconst asyncForm = AsyncComponent(()=&gt;import('./page/form/Form'));class Routes extends React.Component { render() { return (&lt;Switch&gt; &lt;Route path=\"/form\" component={asyncForm}&gt;&lt;/Route&gt; &lt;/Switch&gt;) }} React.lazy React.lazy就是用于动态加载组件的工具包 注意：React.lazy 和 Suspense 尚不可用于服务器端渲染。如果要在服务器渲染的应用程序中进行代码拆分，我们建议使用 Loadable Components。它有一个很好的服务器端渲染打包拆分指南。 123456const OtherComponent = React.lazy(()=&gt;import('./OtherComponent'));function MyComponent(){ return ( &lt;div&gt;&lt;OtherComponent/&gt; &lt;/div&gt; )} Suspense 当组件还未加载完成时，可以渲染一些loading动画，这时，可以使用Suspense组件完成 12345678910const OtherComponent = React.lazy(()=&gt;import('./OtherComponent'));function MyComponent(){ return ( &lt;div&gt; &lt;Suspense fallback={&lt;div&gt;loading....&lt;/div&gt;}&gt; &lt;OtherComponent/&gt; &lt;/Suspense&gt; &lt;/div&gt; )} fallback prop（属性） 接受在等待加载组件时要渲染的任何 React 元素 错误处理ErrorBoundaries 当其他模块无法加载（如：网络故障时），则会触发错误，这时可以使用React拿出的错误边界处理Error Boundary。 如果一个类组件定义了生命周期方法中的任何一个（或两个）static getDerivedStateFromError() 或componentDidCatch()，那么它就成了一个错误边界。 使用static getDerivedStateFromError()在抛出错误后渲染回退UI。 使用 componentDidCatch() 来记录错误信息。 注意 错误边界(Error Boundaries) 仅可以捕获其子组件的错误。 123456789101112131415161718192021222324252627282930313233class ErrorBoundary extends React.Component { constructor(props) { super(props); this.state = { error: null, errorInfo: null }; } componentDidCatch(error, errorInfo) { // Catch errors in any components below and re-render with error message this.setState({ error: error, errorInfo: errorInfo }) // You can also log error messages to an error reporting service here } render() { if (this.state.errorInfo) { // Error path return ( &lt;div&gt; &lt;h2&gt;Something went wrong.&lt;/h2&gt; &lt;details style={{ whiteSpace: 'pre-wrap' }}&gt; {this.state.error &amp;&amp; this.state.error.toString()} &lt;br /&gt; {this.state.errorInfo.componentStack} &lt;/details&gt; &lt;/div&gt; ); } // Normally, just render children return this.props.children; } } 以上，当出现错误时，this.state.errorInfo为true，则会渲染预设好的错误展示页面，没错则直接渲染子组件内容 错误边界的粒度完全取决于你的应用。你可以将其包装在最顶层的路由组件并为用户展示一个 “发生异常（Something went wrong）“的错误信息，就像服务端框架通常处理崩溃一样。你也可以将单独的插件包装在错误边界内部以保护应用不受该组件崩溃的影响。 上下文Context上下文context提供了一种通过组件树传递数据的方法，无需在每个级别手动传递props属性。 何时使用Context? Context 旨在共享一个组件树内可被视为 “全局” 的数据,例如当前经过身份验证的用户，主题或首选语言等。 当你不想在组件树中通过逐层传递props或者state 的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。 如何使用Context？ 要context发挥作用，需要用到两种组件，一个是context生产者（Provider）[通常是父节点]，一个是消费者Consumer【通常是一个或多个子节点】—— 所以context的使用是基于生产者消费者模式 参考文章：React Context 的理解以及应用 Context对应的API React.createContext(defaultValue) 用于创建一个context对象，其中defaultValue为默认初始值，当Provider中没有匹配的value时，会在defaultValue中查找1const MyContext = React.createContext(); Context.Provider 生产者，作为一个组件，用它包裹的后代组件将共享它的value属性，当value属性发生变化时，所有作为 Provider(提供者) 后代的 consumer(使用者) 组件 都将重新渲染。1&lt;MyContext.Provider value={/*some value*/}&gt; Context.Consumer 一个可以订阅 context 变化的 React 组件。需要接收一个函数作为子节点。该函数接收当前 context 值并返回一个 React 节点，基参数即为Provider中传入的value属性值（对象）或者createContext中的defaultValue12345 &lt;MyContext.Consumer&gt; {({theme}) =&gt; ( &lt;button style={{backgroundColor: theme.background}}&gt;主题色&lt;/button&gt; )}&lt;/MyContext.Consumer&gt; Class.contextType 在React的普通Class组件中，通过contextType声明分配由React.createContext()创建的Context 对象。之后便可以使用this.context使用该context对象的value值1234567class MyClass extends React.Component { static contextType = MyContext; render() { let value = this.context; /* render something based on the value */ }} 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// themecontext.jsimport React from 'react';export const themes= { light:{ foreground:'#000', background:'#eee' }, dark:{ foreground: '#fff', background:'#222' }};export const ThemeContext=React.createContext( themes.dark);// themeButton.jsimport {ThemeContext} from \"./theme-context\";import React from 'react';export default class ThemeButton extends React.Component{ static contextType=ThemeContext; render(){ let props = this.props; let theme = this.context; return ( &lt;div&gt; &lt;button {...props}&gt;&lt;/button&gt; &lt;div style={{width:100,height:100,background:theme.background}}&gt;&lt;/div&gt; &lt;/div&gt; ) }}// Context.jsimport React from 'react';import {ThemeContext,themes} from \"./theme-context\";import ThemeButton from './theme-button'function Toolbar(props){ return ( &lt;ThemeButton onClick={props.changeTheme}&gt; Change Theme &lt;/ThemeButton&gt; )}class Context extends React.Component { constructor(props) { super(props); this.state={ themes:themes.light, }; } toggleTheme=()=&gt;{ this.setState((preState)=&gt;{ return { themes:preState.themes===themes.dark?themes.light:themes.dark } }); }; render() { return (&lt;div&gt; &lt;ThemeContext.Provider value={this.state.themes}&gt; &lt;Toolbar changeTheme={this.toggleTheme}&gt;&lt;/Toolbar&gt; &lt;/ThemeContext.Provider&gt; &lt;/div&gt;) }}export default Context; 更多示例参考：context上下文 Refs Refs提供了一个对真实DOM（组件）的引用，我们可以通过这个引用直接操作DOM（跟vue的refs类似） 什么时候用?? 当需要处理元素的focus,文本的选择或者媒体的播放等，以及触发强制动画或者同第三方库集成的时候。 如何用？：在V16版本后，官方提供了React.createRef()这个API用于创建Ref变量，然后再将这个变量赋值给组件声明中ref属性就好了。 参考详情：Refs和DOM元素、转发Refs 12345678910111213141516171819202122232425class fancy extends React.Component { constructor(props) { super(props); this.textInput=React.createRef(); this.focusInput=this.focusInput.bind(this); } focusInput(){ // 通过this.xxx.current获取组件 this.textInput.current.focus(); } render() { return (&lt;div&gt; &lt;h3&gt;这将有一个button&lt;/h3&gt; &lt;div&gt; &lt;input ref={this.textInput} type=\"text\" /&gt; &lt;button onClick={this.focusInput}&gt;按钮呀&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;) }}// 在v16版本之前// 元素上ref属性定义 &lt;input ref={ele=&gt;{this.textInput=ele}} type=\"text\" /&gt; // 获取ref值 this.textInput.focus(); 在v16版本后，通过createRef()来生成ref并赋值给对应组件或DOM元素。之前是通过在元素上ele=&gt;this.refName=ele完成赋值 在v16版本后，通过this.refName.current来获取refName对应对应组件或DOM元素。之前是直接通过this.refName获取 当ref属性赋在DOM元素上时，this.refName.current返回的就是DOM元素，当赋给React组件时，this.refName.current返回的就是React组件 不能在函数式组件上使用ref属性，但可以在函数式组件内部的子组件中使用ref属性 传递Refs 当父组件需要拿到子组件的ref时，在v16版本后可以通过React.forwardRef()实现 思路：通过父组件向子组件传递ref属性，在子组件中获取到父组件赋值的ref值后，对应的赋给相应元素实现ref的传递 123456789101112131415161718192021222324252627// 示例1：简单函数式组件中传递ref。如下，通过this.refFan.current可以直接获取到buttonconst FancyButton = React.forwardRef((props,ref)=&gt;( &lt;div&gt; &lt;h3&gt;子组件&lt;/h3&gt; &lt;button ref={ref}&gt;{props.children}&lt;/button&gt; &lt;/div&gt;));const refFan = React.createRef();&lt;FancyButton ref={refFan}&gt;我是按钮&lt;/FancyButton&gt;// 示例2：在类组件中传递Ref// child.jsimport React from 'react';class Child extends React.Component { render() { const {forwardedRef,...rest} = this.props; return( &lt;div&gt; &lt;h3&gt;这是子组件的另一个按钮&lt;/h3&gt; &lt;button ref={forwardedRef}&gt;另一个按钮&lt;/button&gt; &lt;/div&gt; ) }}export default React.forwardRef((props,ref)=&gt;(&lt;Child forwardedRef={ref}/&gt;));// parent.jsthis.childRef= React.createRef();&lt;Child ref={this.childRef}&gt; 通过React.forwardRef包裹组件用于传递父组件赋值的ref 在类组件中，通过属性forwardedRef来获取父组件赋值的ref,并赋给对应的元素或组件实例 片段Fragment React中一种常见模式是为一个组件同时返回多个并列元素。而render只接受一个子组件，所以通过片段（Fragment）可以将子元素列表添加到一个分组中，且不会在DOM中增加多余的节点。应用场景 通过&lt;React.Fragment&gt;来表示这是一个代码片段。（类似于Vue的&lt;template&gt;标签） &lt;React.Fragment&gt;支持key属性，即当使用data.map返回列表时，可以直接在&lt;React.Fragment&gt;标签上设置key={xxx}1234567891011121314151617181920212223// table.jsclass Table extends React.Component { render() { return ( &lt;table&gt; &lt;tr&gt; &lt;Columns /&gt; &lt;/tr&gt; &lt;/table&gt; ); }}// column.jsclass Columns extends React.Component { render() { return ( &lt;React.Fragment&gt; &lt;td&gt;Hello&lt;/td&gt; &lt;td&gt;World&lt;/td&gt; &lt;/React.Fragment&gt; ); }}","link":"/2017/07/19/React高级指南/"},{"title":"React高级指南二","text":"入门React后，基本上可以写一个小型项目了，但React还有很多高级功能及API可以上手方便开发。以下便是React进阶教程说明。参考文档-react中文文档 目录 高阶组件HOC 深入JSX 渲染属性 PropTypes类型检查 不受控组件 ReactDOM的API 常见问题 事件处理函数 State和Props 项目文件结构 高阶组件HOC 高阶组件（HOC-Higher-Order-Components）是 React 中用于重用组件逻辑的高级技术。高阶组件是一个函数，能够接受一个组件并返回一个新的组件。简单来说，高阶组件将一个组价转化（包装）成另外一个组件。在第三方组件库中，HOC非常常见。如例如Redux的connect 和 Relay’s createFragmentContainer。 高级组件是纯函数，没有副作用。1234567891011121314151617// 示例1：创建一个高阶组件，使每个组件在更新时，打印其新旧prop值// hocWrapper.jsexport default function logProps(WrappedComponent){ return class extends React.Component{ componentDidUpdate(prevProps){ console.log('old props',preProps); console.log('new props',this.props) } render(){ return &lt;WrappedComponent {...this.props}/&gt; } }}// componentOne.jsimport logProps from './hocWrapper';class More extends React.Component{....}export default logProps(More) 如上，每当传入More组件的props发生变化时，都会打印其prop修改状况 注意：不要改变原始组件原型，推荐用容器组件组合包裹组件且不修改包裹组件【如示例】。 注意：不要在render函数中使用高阶组件 注意：Refs不会被传递，若向一个高阶组件赋值ref，那么通过这个ref拿到的是最外层的窗口组件。解决这个问题可以使用React.forwardRefAPI 注意：高阶组件的静态方法需要从原组件进行复制，即HOCComponet.staticMethod = WrappedComponent.staticMethod; 深入JSX 从本质上讲，JSX只是为React.createElement(component, props, ...children)函数提供的语法糖。12345678// JSX代码&lt;MyButton color=\"blue\" shadowSize={2}&gt;Click Me&lt;/MyButton&gt;// 编译为【类似于Vue的render方法】React.createElement( MyButton, {color:'blue',shadowSize:2}, 'Click Me') 用户定义组件必须以大写字母开头 JSX可以使用.语法。如：&lt;React.Fragment&gt;&lt;/React.Fragment&gt; 若没给prop属性传值，那么他默认为true。如：&lt;MyTextBox autocomplete /&gt;中autocomplete默认为true JSX表达式中，标签内的元素可以通过props.children获取到，即内容插槽。props.children可以是字符串内容，也可以是DOM标签或者React组件实例 Boolean，Null,Undefined会被忽略。false，null，undefined，和 true 都是有效的的 children(子元素) 。但是并不会被渲染。这在条件渲染React元素时非常有用。 插槽Portals Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。Portals看似跟{ptops.children}功能类似，但其主要功能是，它可以将子元素插入到任意的DOM节点位置详细解读：官方文档–插槽Portals123456789101112131415161718// props.children展示子元素render() { // React 装载一个新的 div，并将 children 渲染到这个 div 中 return ( &lt;div&gt; {this.props.children} &lt;/div&gt; );}//将子元素插入到任意DOM节点render() { // React *不* 会创建一个新的 div。 它把 children 渲染到 `domNode` 中。 // `domNode` 可以是任何有效的 DOM 节点，不管它在 DOM 中的位置。 return ReactDOM.createPortal( this.props.children, domNode, );} 通过react.createPortal可以实现如Modal，对话框等特定组件功能 渲染属性 “render prop” 是指一种技术，用于使用一个值为函数的 prop 在 React 组件之间的代码共享。 使用Render props的库包括React Router和Downshift 参考文章：渲染属性renderrender prop 是一个组件用来了解要渲染什么内容的函数 prop。 关于 render props 一个有趣的事情是你可以使用一个带有 render props 的常规组件来实现大量的 高阶组件 (HOC)。 123&lt;DataProvider render={data =&gt; ( &lt;h1&gt;Hello {data.target}&lt;/h1&gt;)}/&gt; 示例：封装一个记录鼠标坐标的组件，且可扩展使用图片跟随鼠标移动 思路：1、创建一个Mouse组件用于跟随和显示鼠标，2、通过render属性向Mouse组件传递需要扩展的内容 12345678910111213141516171819202122232425262728293031323334353637383940// Mouse.jsclass Mouse extends React.Component{ constructor(props) { super(props); this.handleMove=this.handleMove.bind(this); this.state={ x:0, y:0 } } handleMove(e){ this.setState({ x:e.clientX, y:e.clientY }) } render() { return ( &lt;div style={{height:'500px',width:'800px',background:'#ff0'}} onMouseMove={this.handleMove}&gt; {this.props.render?this.props.render(this.state):&lt;p&gt;the mouse position is ({this.state.x},{this.state.y})&lt;/p&gt;} &lt;/div&gt; ) }}// 扩展用的图片class Cat extends React.Component{ render(){ const mouse = this.props.mouse return &lt;img src=\"./cat.jpg\" style={{position:'absolute',left:mouse.x,top:mouse.y}} alt=\"\"/&gt; }}// 组合class MouseTracker extends React.Component { render() { return (&lt;div &gt; &lt;h1&gt;Move the mouse around!&lt;/h1&gt; &lt;Mouse render={mouse=&gt;(&lt;Cat mouse={mouse}/&gt;)}/&gt; &lt;/div&gt;) }} 这里的render属性不一定非要用render表示，只是方便解读，它可以是任意命名的属性，只是一个返回值是组件的渲染函数 PropTypes类型检查 注意：从v15.5开始，React.PropTypes助手函数已被弃用，需要单独引入prop-types库来定义contextTypes123456789import PropTypes from 'prop-types';class Hello extends React.Component{ render(){ return(&lt;h1&gt;Hello,{this.props.name}&lt;/h1&gt;) }}Hello.propTypes={ name:PropTypes.string} 更多prop-types对应的类型：使用PropTypes进行类型检查 默认Prop值 通过defaultProps属性可以设置组件的默认属性值：123MyComponent.defaultProps={ name:'haha'} 不受控组件 在处理表单的时候，推荐使用受控组件。当然，也可以使用不受控组件来处理。相对于为每个状态更新编写一个事件处理程序，不受控组件的值可能通过使用一个ref来从DOM获得表单值。 默认值：通过defaultValue来表示不受控组件的默认值。对于checkbox则使用defaultChecked来设置默认值 file Input : 在React中file Input永远是一个不受控制的组件，因为它的值只能由用户设置，而不是以编程方式设置。通过给file input添加ref属性来获取到file input对应的files文件123456789101112131415161718192021222324class Form extends React.Component{ constructor(){ super(); this.textInput = React.createRef(); this.fileInput = React.createRef(); this.submitForm=this.submitForm.bind(this); } submitForm(e){ e.preventDefault(); const userName = this.textInput.current.value; const fileName = this.fileInput.current.files[0].name console.log(userName,fileName) } render(){ return ( &lt;div&gt; &lt;input defaultValue=\"lala\" name=\"username\" type=\"text\" ref={this.textInput}/&gt; &lt;input name=\"file\" type=\"file\" ref={this.fileInput}/&gt; &lt;button onClick={this.submitForm}&gt;点我&lt;/button&gt; &lt;/div&gt; ) }} ReactDOM的API常见问题事件处理函数 如何绑定？：onClick={this.handleClick}用于绑定 如何确保处理函数在组件实例作用域内？: 在constructor中，通过this.handleClick=this.handleClick.bind(this)绑定作用域 使用箭头函数来声明处理函数，handleClick=()=&gt;{xxx} 在render中使用bind绑定【此方法会在每次组件渲染时创建一个新函数，而影响性能】，&lt;button onClick={this.handleClick.bind(this)}&gt;Click Me&lt;/button&gt; 在render中使用箭头函数【同3一样，会影响性能】,&lt;button onClick={() =&gt; this.handleClick()}&gt;Click Me&lt;/button&gt; 如何传参？： 使用bind:&lt;button onClick={() =&gt; this.handleClick(id)} /&gt; 通过data-*属性传参：&lt;button data-letter={letter} onClick={this.handleClick}/&gt;，在handleClick中通过e.target.dataset.letter拿取data-letter的值 State和Props 区别？：state是组件内部管理的，而props是从外部付入的 state是异步的，如果更新state需要用到当前的state，那么应该向setState中传入一个函数，而不是对象。this.setState((prevState)=&gt; return {count:prevState+1}) 第三方状态管理：像redux或者Mobx的状态管理库都挺好的，但是如果项目体量小，其实只用React也是可以实现的 项目文件结构 项目文件该以何种结构来组织？这其实不是一个应该纠结的问题。有以下几种设置项目目录结构的方式： 资源就近维护：将CSS，JS和测试文件一起放入按功能或路由分组的文件夹中 按文件类型来分组：如imgs统一维护项目图片 AJAX及APIs 如何发送AJAX？：你可以使用任意你喜欢的库，如Axios，jQuery Ajax或浏览器自带的window.fetch 何时发送？：在componentDidMount生命周期方法内发送Ajax请求数据。这样你才能够在请求的数据到达时使用 setState 更新你的组件。 如何取消发送Ajax?：在componentWillUnmount生命周期中取消未完成的Ajax请求。如在axios中，this.serverReq=axios.get(xxx).再在componentWillUnmount中通过this.serverReq.abort()取消","link":"/2017/07/26/React高级指南二/"},{"title":"Node Web开发框架-Express","text":"Express是基于Node.js平台的极简的经典Web开发框架。中文官网 目录 安装 HelloWorld Express应用生成器 Router路由 静态文件 中间件 模板引擎 Express设置代理 常见问题 安装 前提：已安装Node.js 12345678$ mkdir myapp$ cd myapp# 初始化文件[中间会出现一些询问命令按需进行]$ npm init# 安装$ npm install express -S HelloWorld myapp目录下，新建app.js作为入口文件 示例：用express创建一个简单的web服务123456const express = require('express')const app = express()app.get('/', (req, res) =&gt; res.send('Hello World!'))app.listen(3000, () =&gt; console.log('Example app listening on port 3000!')) 1node app.js 访问localhost:3000可以看到页面显示了Hello World，访问其他页面会出现404，这就是一个简单的web应用服务 Express应用生成器 express提供了用于快速生成一个web应用程序的工具express-generator，它可以快速创建项目骨架，并包含多个基本应用模块 123456789# 安装$ npm install express-generator -g# 查看express指令$ express -h# 创建一个以ejs为模板引擎的应用$ express --view=ejs myapp# 启动应用[默认是在3000端口启动]$ npm start 通过生成器创建的应用一般都有如下目录结构： 1234567891011121314151617.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.pug ├── index.pug └── layout.pug Router路由路由：决定了应用如何响应客户端请求，针对请求不同的URI或Path，以及不同的请求方式（get/post），会作出不同的响应 app是express的实例，METHOD对应前端请求方式，PATH对应前端请求路径，HANDLER对应当匹配路由时的响应函数 12345678910111213//get请求app.get('/next',function(req,res,next){ res.send('针对next的请求');})// post请求app.post('/set',function(req,res,next){ res.send('这是一个post请求')})//所有请求app.all('/all',functino(req,res,next){ console.log('进到了/all') next();}) app.all()比较特殊，主要用于对所有请求都加载中间件函数 在项目中，路由都是分模块的，如上，index则代表主要首页模块，在routes/index文件中，又有多个路由可参考写法。 路由参数（parameters） 参考文档 路由路径中，?, +, *, ()可以正则的方式来匹配路径 req.params中可以获取到通过请求url/:param下的参数param 1234567891011121314// 1、正则匹配[示例匹配abe或abcde]app.get('/ab(cd)?e',function(req,res){ res.send('ab(cd)?e')})// 2、req.params的使用Route path: /users/:userId/books/:bookIdRequest URL: http://localhost:3000/users/34/books/8989req.params: { \"userId\": \"34\", \"bookId\": \"8989\" }// 3、params的扩展使用，()匹配Route path: /user/:userId(\\d+)Request URL: http://localhost:3000/user/42req.params: {\"userId\": \"42\"} 路由回调 app.get('url',callback)：其中callback回调可以是一个函数，也可以是一个函数构成的数组，也可以是数组加函数，详见文档 route支持链式调用1234567app.route(&apos;/book&apos;) .get(function (req, res) { res.send(&apos;Get a random book&apos;) }) .post(function (req, res) { res.send(&apos;Add a book&apos;) }) Response方法 方法名 作用 res.download() 提供一个文件下载 res.end() 终止响应进程 res.json() 返回json对向响应 res.jsonp() 响应一个jsonp格式的json对向 res.redirect() 重定向 res.render() 向前端渲染一个模板 res.send() 发送通用类型的响应 res.sendFile() 以文件流方式发送文件 res.sendStatus() 设置响应code，并发送响应 express.Router 路由模块 项目中，通常路由是按模块来区分的，而不是全部写在app.js中，如下：123456789101112131415161718192021// index.jsvar express = require('express');var router = express.Router();// 使用中间件router.use(function timelog(req,res,next){ console.log('Time: ', Date.now()) next()})// 路由router.get('/', function (req, res) { res.send('Birds home page')})router.get('/about', function (req, res) { res.send('About birds')})// app.js中var index = require('./router/index.js')app.use('/',index); 静态文件 为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，可以使用 Express 中的express.static内置中间件函数。 示例：访问public目录下的所有文件 123456789app.use(epxress.static('public'))// 若要使用多个静态资源目录，则多次调用express.static中间件函数// '/static'设置前缀地址来访问资源app.use('/static',express.static('public'))app.use(express.static('files'))// 通常的做法app.use('/static', express.static(path.join(__dirname, 'public'))) 中间件 中间件函数可以处理请求对象(req)，响应对象(res)，以及next函数。通常中间件是用来对请求或响应进行包装和处理。 示例– 添加一个 myLogger中间件（用于打印日志）和一个requestTime中间件用于展示请求时间 12345678910111213141516171819202122// web应用const express = require('express');const app = new express();// myLogger中间件var myLogger = function(req,res,next){ console.log('LOGGER') next();}app.use(myLogger); //使用中间件// requestTime中间件var requestTime = function(req,res,next){ req.requestTime = Date.now(); next();}app.use(requestTime); //使用中间件app.get('/',function(req,res){ res.send('Hello U')})app.listen(3000) 可配置的中间件 例如express的cookieSession中间件，可用于处理用户session1234567891011// my-middleware.jsmodule.exports = function(options) { return function(req, res, next) { // 基于options选项来执行逻辑 next() }}//使用var mw= requrie('./my-middleware.js');app.use(mw(option1:'1',option2:'2')) 第三方中间件 cookie-parser：用于处理123456var express = require(&apos;express&apos;)var app = express()var cookieParser = require(&apos;cookie-parser&apos;)// load the cookie-parsing middlewareapp.use(cookieParser()) 模板引擎 通过app.set('view engine', 'ejs')可设置模板引擎 通过app.set('views','./views')可设置渲染模板 1234// 设置模板app.get('/', function (req, res) { res.render('index', { title: 'Hey', message: 'Hello there!' })}) Express设置代理 文档 通过app.set('trust proxy',params)来设置代理，params有多种可能，如下： Boolean值：为true时，激活反向代理，默认未激活状态false 数据库集成 详见文档 常见问题1. 如何处理404响应 在Express中，404响应不是错误，所以需要一个针对404的中间件来捕获它 123app.use(function (req, res, next) { res.status(404).send(\"Sorry can't find that!\")}) 当然，也可以用设置好的404页面通过res.render的方式渲染到客户端 2. 设置一个错误处理器 express生成的项目中，默认是有捕获错误的中间件的，当然也可以自己写，如下示例： 在异步函数中，必须要使用next()来传递错误给express并捕获相应错误 12345678910111213141516171819202122232425262728// 简单的错误处理中间件app.use(function (err, req, res, next) { console.error(err.stack) res.status(500).send('Something broke!')})// 异步函数中的错误处理app.get(\"/\", function (req, res, next) { fs.readFile(\"/file-does-not-exist\", function (err, data) { if (err) { next(err); // 将错误传递给express } else { res.send(data); } });});// express生成项目中，默认的处理器app.use(function(err, req, res, next) { // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : {}; // render the error page res.status(err.status || 500); res.render('error');});","link":"/2016/10/25/Express/"},{"title":"Nginx入门教程","text":"简介Nginx是一个轻量级的HTTP服务框架优点： 支持海量高并发 内存消耗少 免费使用可以商业化 配置文件简单 Linux下运维环境搭建教程默认在Linux操作系统中安装使用，此交使用的是CentOS 7.412yum -y install gcc gcc-c++ autoconf pcre-devel make automakeyum -y install wget httpd-tools vim 目录 Nginx环境搭建 查询与配置 操作nginx Nginx反向代理的设置 自定义错误页 访问权限设置 Nginx设置虚拟主机 Nginx适配PC或移动设备 Nginx的Gzip压缩配置 CentOS下安装Node Nginx环境搭建安装 先安装Nginx源（用于yum安装） 1rpm -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 再安装Nginx 1yum install -y nginx Nginx默认目录:whereis nginx 以下是Nginx的默认路径：(1) Nginx配置路径【常用】：/etc/nginx/(2) PID目录：/var/run/nginx.pid(3) 错误日志：/var/log/nginx/error.log(4) 访问日志：/var/log/nginx/access.log(5) 默认站点目录：/usr/share/nginx/html事实上，只需知道Nginx配置路径，其他路径均可在/etc/nginx/nginx.conf 以及/etc/nginx/conf.d/default.conf 中查询到。 查看Nginx版本：nginx -v 查询与配置1. 查看Nginx安装目录1rpm -ql nginx rpm是linux的rpm包管理工具，-q代表询问模式，-l代表返回列表 2. 配置文件nginx.conf文件是Nginx总配置文件，在我们搭建服务器时经常调整这个文件。目录一般在：etc/nginx 如下是一个nginx.conf的一般内容 123456789101112131415161718192021222324#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1; #错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events { worker_connections 1024; # 单个后台进程的最大并发数}http { include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件 最后一行包含的是子配置项的内容，可以进入到conf.d目录，使用vim default.conf进行查看 123456789101112131415161718192021222324252627282930313233343536373839# default.conf文件内容server { listen 80; #配置监听端口 server_name localhost; //配置域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; # 权限设置 location / { root /usr/share/nginx/html; #服务默认启动目录 index index.html index.htm; #默认访问文件 } #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html { root /usr/share/nginx/html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #}} 上面可见，服务目录放在/usr/share/nginx/html下 操作nginx1. 启动nginx 通过命令：nginx直接启动nginx 1234# 普通nginx# 常用启动方式systemctl start nginx.service 启动后没有任何提示，可以通过下面命令查询服务 1ps aux | grep nginx 启动nginx服务后，如果是在阿里云或腾讯云服务器上装的，那么通过设置安全组信息（放开80端口）后，就可以通过公网IP进行访问了。若有域名，可以将域名先解析到服务器的公网IP，再通过域名访问更方便 2. 停止Nginx服务12345678# 立即停止服务，强制性的nginx -s stop# 从容停止服务，完成当前工作后停止nginx -s quit# 杀死nginx进程killall nginx# 系统服务方式停止systemctl stop nginx.service 3. 重启nginx服务123456# 重启systemctl restart nginx.service# 重新载入配置文件【若修改了nginx配置文件，都需要重载一下】nginx -s reload# 查看端口号netstat -tlnp 一般情况下nginx启动通过80端口提供HTTP访问 Nginx反向代理的设置我们现在的web模式基本的都是标准的CS结构，即Client端到Server端。那代理就是在Client端和Server端之间增加一个提供特定功能的服务器，这个服务器就是我们说的代理服务器。 关键词：location，proxy_pass 正向代理：如翻墙工具就是一个典型的正向代理工具。代理服务器proxy代理客户端去访问服务器 反向代理：现在基本所有大型网站的页面都是用的反向代理。代理服务器proxy代理服务端 客户端发送的请求，想要访问server服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。 通过图片的对比，应该看出一些区别，这里proxy服务器代理的并不是客户端，而是服务器,即向外部客户端提供了一个统一的代理入口，客户端的请求都要先经过这个proxy服务器。具体访问那个服务器server是由Nginx来控制的。再简单点来讲，一般代理指代理的客户端，反向代理是代理的服务器。 反向代理的用途和好处 安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。 功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡。 举例 如将访问HTTP的首页（假如是：http://mywebsite.com）代理到http://www.baidu.com去（即当访问公网http://mywebsite.com时，会跳转到baidu）1234567server { listen 80; server_name _; location / { proxy_pass http://www.baidu.com; }} 其它反向代理指令反向代理还有些常用的指令，我在这里给大家列出： proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。 proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。 proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。 proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。 proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。 自定义错误页在上面的配置中可以看到一行：error_page 500 502 503 504 /50x.html,即当访问出现500等错误时，就会返回50x.html。nginx对外访问的文件夹为：/usr/share/nginx/html。因此，如果要自定义页面或者以后上传网站页面都放在这个目录下。 这里推荐使用WinSCP来进行FTP文件上传。下载地址 示例：添加一个404错误页 首先：准备好一个要显示的404.html 配置nginx.conf的errorPage12345678# 进入配置目录cd etc/nginx# 打开nginx.conf默认配置vim nginx.conf# 修改配置error_page 500 502 503 504 /50x.html;# 新增的error_page配置。注意加分号error_page 404 /404.html; 重启nginx12nginx -s quitnginx 此外，404错误也可以配置指向到另一个网址123456# 修改配置【Esc :wq保存】vim nginx.conferror_page 404 http://baidu.com;# 保存重启nginx -s quitnginx 访问权限设置location选项为nginx.conf中用于配置权限的属性。123456789# 默认的配置location / { root html; index index.html index.htm; # 新增一项禁止访问(下面禁止某一IP访问) deny 181.214.193.17 # 允许访问(下面允许所有访问) allow all;} 注意：上面的配置优先从上到下匹配，若deny在allow前面则先匹配它 12345location / { deny all; # 下面allow这项将不会起作用，因为前一行deny all allow 181.124.193.15;} deny：禁止访问,设置后访问基设置的内容，将出现403 forbidden错误 allow:允许访问12345678 # = 用于精确匹配location =/img { allow all;}# 正则匹配 ~locatin ~\\.php$ { # 以.php结尾的都不让访问 deny all;} Nginx设置虚拟主机虚拟主机是指在一台物理主机服务器上划分出多个磁盘空间，每个磁盘空间都是一个虚拟主机，每台虚拟主机都可以对外提供Web服务，并且互不干扰。在外界看来，虚拟主机就是一台独立的服务器主机，这意味着用户能够利用虚拟主机把多个不同域名的网站部署在同一台服务器上，而不必再为建立一个网站单独购买一台服务器，既解决了维护服务器技术的难题，同时又极大地节省了服务器硬件成本和相关的维护费用。 配置虚拟主机可以基于端口号、基于IP和基于域名 1. 基于端口号配置虚拟主机原理：Nginx监听多个端口，根据不同的端口号，来区分不同的网站。可以直接在etc/nginx/nginx.conf文件里配置 vim nginx.conf进入到配置页【先在/usr/share/nginx/html中创建8001文件夹并放入index.html】 1234567# 新增一个server块server { listen 8001; # 监听端口号 server_name localhost; #配置匹配的域名 root /usr/share/nginx/html/html8001; #配置匹配的资源路径 index index.html; # 配置首页} 保存后重启nginx。 curl http://localhost:8001访问8001端口内容会返回对应html。(或者外部通过： 服务器公网IP：8001 来访问) 2. 基于IP配置虚拟主机基于IP和基于端口的配置几乎一样，只是把server_name选项，配置成IP就可以了。123456server{ listen 80; server_name 112.74.164.244; root /usr/share/nginx/html/html8001; index index.html;} 一般买的云服务器默认只有一个公网IP的，所以这种方法暂时用不到。 3. 基于域名配置虚拟主机实际应用中，访问网站都是用的域名，而一台服务器上可以提供对多个网站的访问，而不同网站的域名需要进行配置。在nginx.conf中，配置server，其中server_name对应的就是你的域名， 例：设置不同的域名（或一个域名下多个二级域名）的访问。 sub.mysite.com: 这个域名映射到html下某一文件夹8001下的首页。 mysite.com:这个域名映射到默认的Nginx首页位置。 前提需要解析好对应的域名，使域名对应主机IP1234567891011121314151617# 配置nginx.confserver { listen 80; server_name mysite.com; location / { root /usr/share/nginx/html; index index.html index.htm; }}server { listen 80; server_name sub.mysite.com; location / { root /usr/share/nginx/html/8001; index index.html index.htm; }} Nginx适配PC或移动设备现在很多网站都是有了PC端和H5站点的，因为这样就可以根据客户设备的不同，显示出体验更好的，不同的页面了。虽然用自适应前端样式也可以实现，但从复杂性和易用性上都不如分开编写的好，如淘宝，京东这些大型网站就都没有采用自适应，而是用分开制作的方式。 Nginx适配PC或移动设备的作用在于: Nginx会根据访问对向是PC还是移动设备，而程现不同的访问地址，对应着不同端的显示界面。（例如，电脑进入淘宝时，返回的是PC网页 www.taobao.com，若开启开发者模式的手机端调试，刷新后，网站会变成 h5.m.taobao.com）。 关键点：Nginx提供了if语句，并有$http_user_agent变量作为客户端的userAgent1234567891011server { listen 80; server_name www.kingdou.com; location / { root /usr/share/nginx/pc; if ($http_user_agent ~* 'Android|webOS|iPhone|iPod|BlackBerry') { root /usr/share/nginx/mobile; } index index.html; }} Nginx的Gzip压缩配置Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。从上图可以清楚的明白，gzip是需要服务器和浏览器同事支持的。当浏览器支持gzip压缩时，会在请求消息中包含Accept-Encoding:gzip,这样Nginx就会向浏览器发送经过gzip后的内容，同时在相应信息头中加入Content-Encoding:gzip，声明这是gzip后的内容，告知浏览器要先解压后才能解析输出。 gzip的配置项 gzip : 用于开启或关闭gzip模块 gzip_buffers: 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_comp_level: gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable: 通过该指令对一些特定的User-Agent不使用压缩功能。 gzip_min_length :设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。 gzip_http_version: 识别HTTP协议版本，其值可以是1.1.或1.0. gzip_proxied: 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。 gzip_vary:用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。 示例123456http { ... gzip on; gzip_types text/plain application/javascript text/css; ... } gzip on是启用gizp模块，gzip_types是用于在客户端访问网页时，对文本、JavaScript 和CSS文件进行压缩输出。 浏览器开发者模式中，可以看到HTTP响应头信息中Content-Encoding为gzip类型。","link":"/2018/08/07/Nginx入门/"},{"title":"ReactRouter教程及API","text":"往往React需要与React-router搭配使用，实现前端路由功能。好比vue与VueRouter的搭配，下面主要介绍ReactRouter的使用与主要API用法。React-router文档地址 目录 安装使用 Router对应组件 Router的代码拆分 集成Redux 主要API 安装使用 通常在安装时，会看到有的项目会同时安装有react-router和react-router-dom，其实只要安装react-router-dom就好了，react-router包含的是react-router的核心模块，而react-router-dom则包含了除核心模块以外，针对DOM绑定的组件，如&lt;Link/&gt;,&lt;BrowserRouter/&gt;。 因此，只需要安装react-router-dom就好了，当然，如果搭配使用react-redux则还需要react-router-redux 安装1yarn add react-router-dom 使用：【示例1：基本路由】 123456789101112131415161718192021222324import React from \"react\";import { BrowserRouter as Router, Route, Link } from \"react-router-dom\";const Index = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;const About = () =&gt; &lt;h2&gt;About&lt;/h2&gt;;export default AppRouter = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;/li&gt; &lt;li&gt; &lt;Link to=\"/about/\"&gt;About&lt;/Link&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;Route path=\"/\" exact component={Index} /&gt; &lt;Route path=\"/about/\" component={About} /&gt; &lt;/div&gt; &lt;/Router&gt;); 使用：【示例2：路由嵌套】 在一级路由组件中，实现二级路由.以函数式组件为例1234567891011121314151617181920212223242526272829303132import React from \"react\";import { BrowserRouter as Router, Route, Link } from \"react-router-dom\";const Home = () =&gt; &lt;h2&gt;Home&lt;/h2&gt;;export default App = () =&gt; ( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=\"/\"&gt;Home&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=\"/topics\"&gt;Topics&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route exact path=\"/\" component={Home} /&gt; &lt;Route path=\"/topics\" component={Topics} /&gt; &lt;/div&gt; &lt;/Router&gt;);const Child = ({match})=&gt;&lt;h3&gt;这是Topics的子路由对应组件&lt;/h3&gt;const Topic = ({match})=&gt;&lt;h3&gt;返回匹配路径的组件：{match.params.id}&lt;/h3&gt;const Topics = ({ match }) =&gt; ( &lt;div&gt; &lt;h2&gt;Topics组件&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to={`${match.url}/child`}&gt;Child&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to={`${match.url}/topicOne`}&gt;topicOne&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to={`${match.url}/topicTwo`}&gt;topicTwo&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route exact path={`${match.path}/child`} component={Child} /&gt; &lt;Route exact path={match.path} render={() =&gt; &lt;h3&gt;请选择一个子路由&lt;/h3&gt;} /&gt; &lt;Route path={`${match.path}/:id`} component={Topic} /&gt; &lt;/div&gt;); 上面${match.path}/:id可以匹配父路由下的所有路径，因此放在最后，在组件中通过{match.params.id}获取到/:id匹配的任意路径，如：topicOne如上：路由嵌套使用 match对象来匹配上级。match对象含如下属性： isExact:Boolean params:Object，对应路由的参数 path:String， 对应路由path url:String, 对应路由url Router对应组件 在React Router中，有三种类型的组件：Router组件，Route路由匹配组件,Link导航组件。所有组件都需要在react-rouer-dom中引入使用。 Routers react-router-dom提供了&lt;BrowserRouter&gt;和&lt;HashRouter&gt;两种路由模式，如果有服务器端的动态支持，建议使用 BrowserRouter，否则建议使用 HashRouter。hashrouter是以#号方式匹配路由，从url中可以看出来，这个地址对于后端来说，全部指向同一个地址,而browserrouter不存在#的，不同的路由对于后端也是不同的地址。 Route 路由匹配组件 有两种路由匹配组件：&lt;Route&gt;和&lt;Switch&gt;。 路由匹配组件通过对比其path属性与当前浏览器的pathname是否一致来决定是否渲染其内容。如果一个&lt;Route&gt;没有path属性，将会匹配所有路径。 &lt;Switch&gt;组件用于对&lt;Route&gt;组件进行分组组合，switch组件只会选择渲染第一个匹配当前路径的Route组件。这对于多个组件都匹配时比较有用，或者在做路由之间的动画过渡或做404缺省配置时很有用。 Route组件有三种渲染方式： component ： render={MyComponent}经常使用的渲染属性，用于直接设置Route对应渲染的组件内容。 render ： render={()=&gt;&lt;MyComponent someParm={this.state.param}&gt;},常用，render对应一个行内函数。当你需要向这个Route组件传递当前作用域内的参数【如this.state.param】时，就需要用到此方法。 children ： 不常用，后续介绍。 Route组件传入渲染组件的属性： location : 对象，可以简单认为是URL的对象形式表示。注意location.state，这里的state与HTML5 history.pushState API 中的 state 对象一样，每个 URL 都会对应一个 state 对象，你可以在对象里存储数据，但这个数据却不会出现在 URL 中。实际上，数据被存在了 sessionStorage 中。 history ： 对象，它提供了很多有用的方法可以在路由系统中使用，比如history.go()，用于替换当前的 URL，并且会将被替换的 URL 在浏览器历史中删除。函数的第一个参数是 state 对象，第二个是路径； match 导航组件 React Router提供了如下三种导航组件： &lt;Link&gt;组件用于代替html中的a标签。 &lt;NavLink&gt;是Link组件的一种特殊形式，它在Link之上还多出了active样式的功能。当当前路径匹配了NavLink对应的路径时，其会active样式会激活。 &lt;Redirect&gt;组件用于强制跳转到其to属性对应的路径组件中。当你想在当前直接强制重定向到另一页面时可以使用。如在/foo对应组件内使用&lt;Redirect to=&quot;/bar&quot;时，当路径匹配/foo就会直接跳转到/bar对应组件中。1234567891011121314151617import {BrowserRouter as Router,Route,Switch,Link,NavLink} from 'react-router-dom';const MyComponent=&lt;h3&gt;MyComponent&lt;/h3&gt;;const ReactComponent=&lt;h3&gt;ReactComponent&lt;/h3&gt;;const ComponentRedirect=&lt;div&gt;立即跳转：&lt;Redirect to=\"/login\" /&gt;&lt;/div&gt;&lt;Router&gt; &lt;div&gt; &lt;Link to=\"/\"&gt;Home&lt;/Link&gt; &lt;NavLink to=\"/mine\" activeClassName=\"active\"&gt; MyComponent&lt;/NavLink&gt; &lt;NavLink to=\"/react\" activeClassName=\"active\"&gt; React&lt;/NavLink&gt; &lt;Switch&gt; &lt;Route path=\"/react\" component={ReactComponent} /&gt; &lt;Route path=\"/mine\" render={()=&gt;&lt;MyComponent title=\"传进this.props.title的值呀\"/&gt;} /&gt; &lt;Route redirect=\"/toRedirect\" component={ComponentRedirect} /&gt; &lt;/Switch&gt; &lt;/div&gt;&lt;/Router&gt; 注意：Router只能有一个子组件，所以其内容最好用一个div包裹 Router的代码拆分 对比如下两张图： 左图是未做Code Spliting的APP，通常这会导致首屏加载白屏或等待时间过长。右图是拆分后，各组件都动态加载，按需引入。 有以下几种Code Spliting的方法 通过webpack做动态导入import，webpack会在打包时识别动态导入的组件，从而让dynamic imports组件从最终的main.js中分离形成多个不同的js文件，而app会在用到组件时再加载相应的js文件 使用babel对应的插件@babel/plugin-syntax-dynamic-import。当你使用babel来编译jsx文件时，就可以使用此插件，用于告诉webpack进行动态组件的打包 1234{ \"presets\": [\"@babel/react\"], \"plugins\": [\"@babel/plugin-syntax-dynamic-import\"]} 使用react-loadable【推荐】 react-loadable对应github地址及文档：react-loadable react-loadable是一个高阶组件HOC，相比于自己创建一个动态导入函数asyncFunction来动态导入组件，react-loadabel能够处理更多边界情况，且支持服务端渲染。 常用参数： loader:function,传入动态导入对应组件的函数，loader: () =&gt; import(&quot;./Dashboard&quot;) loading:Compnonent,当组件在加载中，或者加载失败时，对应的组件， timeout:ms，对应加载毫秒数，当超时时向Loading组件传入props.timeOut123456789101112131415161718192021222324252627import Loadable from \"react-loadable\";import Loading from \"./Loading\";const LoadableComponent = Loadable({ loader: () =&gt; import(\"./Dashboard\"), loading: Loading});export default class LoadableDashboard extends React.Component { render() { return &lt;LoadableComponent /&gt;; }}// Loading.js组件function Loading(props) { if (props.error) { //加载失败 return &lt;div&gt;Error! &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;; } else if (props.timedOut) { //加载超时 return &lt;div&gt;Taking a long time... &lt;button onClick={ props.retry }&gt;Retry&lt;/button&gt;&lt;/div&gt;; } else if (props.pastDelay) { //加载中 return &lt;div&gt;Loading...&lt;/div&gt;; } else { return null; }} 集成Redux通常情况，react-router和redux适配得挺好的，但是偶尔也会出现路由发生变化但当前组件未被渲染的情况。导致这种情况的原因一般有两种： 组件是通过Redux的connect()(Comp)生成的 组件不是一个Route声明的组件，即此组件未经过&lt;Route component={SomeConnectedThing}/&gt; 为了集成redux与react-router，从而实现通过dispactch来操作导航路由，或者同步路由数据到store中，便可以引用react-router-redux 注意：官网在4.x版本更新时说已经弃用了react-router-redux,在其文档中，推荐了使用connected-react-router作为代替。 123456// beforeexport default connect(mapStateToProps)(Something)// afterimport { withRouter } from 'react-router-dom'export default withRouter(connect(mapStateToProps)(Something)) 像VueRouter的Routes配置一样，配置ReactRouter 如果习惯VueRouter的写法来配置ReactRouter，也是可以的，官方推出了一个工具包：react-router-config 大致配置如下：12345678910111213141516171819202122const routes = [ { component: Root, routes: [ { path: \"/\", exact: true, component: Home }, { path: \"/child/:id\", component: Child, routes: [ { path: \"/child/:id/grand-child\", component: GrandChild } ] } ] }]; 主要APIRoute Route组件是整个ReactRouter的核心部分，用于在当前URL匹配时，做出对应渲染。 渲染模式 Route有三种渲染模式：render,component,children component渲染 当路径匹配时，Route会直接渲染其component属性对应的React组件实例或者DOM。 其会默认向component对应组件的props传入当前URL的location对象12345678&lt;Route path=\"/user/:username\" component={User} /&gt;;class User extends React.Component{ render(){ console.log(this.props) //对应一个location对象，{match:obj,history:obj,location:obj} return &lt;div&gt;User组件&lt;/div&gt; }} render渲染 当需要向路由组件传入额外的参数时，就可以使用render component 的优先级高于render，所以不要同时使用 在render渲染方式中，通过声明式的向内部组件传递props来获取Route对应的match,history,location属性值12345678 &lt;Route path=\"/bar\" render={(props)=&gt;&lt;Bar title={\"这是给Bar的title\"} {...props} /&gt;}&gt;&lt;/Route&gt; class Bar extends React.Component{ render(){ console.log(this.props) //对应一个location对象，{match:obj,history:obj,location:obj} return &lt;div&gt;{this.props.title}&lt;/div&gt; }} children渲染 无论当前path是否匹配，都想要渲染某一组件时，可以使用children1&lt;Route children={()=&gt;&lt;div&gt;啦啦啦&lt;/div&gt;}&gt;&lt;/Route&gt; Route属性 Route有三个属性：match,location,history path: string | string[] 当前Route匹配的path值，可以是字符串，也可以是字符串数组1&lt;Route path={[\"/users/:id\", \"/profile/:id\"]} component={User} /&gt; exact: bool 为true时，只有当其path值与location.pathname完全匹配时才渲染 strict: bool 为true时，其path值需要匹配最后的斜杠/。如下表格： path location.pathname 是否匹配 /one/ /one no /one/ /one/ yes /one/ /one/two yes location: object 默认情况下都是Route的path与浏览器的url做对比，判断是否渲染。而location属性可以提供除浏览器外的对比条件。【暂时不明白】 sensitive: bool 为true时，对大小写敏感，会严格区分大小写 BrowserRouter 使用H5的historyAPI来渲染和处理URL参数： basename:String 全局匹配的URL前缀。12&lt;BrowserRouter basename=\"/calendar\"/&gt;&lt;Link to=\"/today\"/&gt; // 渲染为 &lt;a href=\"/calendar/today\"&gt; getUserConfirmation:func 用于确认跳转时的函数，默认使用window.confirm forceRefresh: bool 如果为true，当页面跳转时会全页刷新， keyLength: number 对应location.key不常用 Children:node 即Router包裹的子组件，只能是唯一的子节点 HashRouter 使用hash来导航页面URL。【注意，hashRouter不支持location.state,location.key】 参数 basename:string 同BrowserRouter getUserConfirmation:func 同BrowserRouter hashType: string 对应window.location.hash的编码方式，其值有3种 “slash” ： 对应会渲染为#/sunshine/lollipops “noslash” ： 对应渲染为#sunshine/lollipops “hashbang” : 对应渲染为#!/sunshine/lollipops【google已弃用】 Children: node 同BrowserRouter Link 用于在应用内声明式的跳转 参数 to: string 值为字符串时，用于直接表示导航的路径，其search值也直接跟在其后1&lt;Link to=\"/courses?sort=name\" /&gt; to:object 值为对象时，有以下几个可选参数 pathname:对应Route组件的path search: 对应导航时的query参数 hash:对应匹配URL的hash值 state: [不清楚]对应location的state12345678&lt;Link to={{ pathname: \"/courses\", search: \"?sort=name\", hash: \"#the-hash\", state: { fromDashboard: true } }}/&gt; replace: bool 为true时，会在history栈中替换当前url值1&lt;Link to=\"/courses\" replace /&gt; innerRef: function 对应返回Link最终渲染出的a标签的DOM，从面可以操作a标签内的DOM123456const refCallback = node =&gt; { // `node` refers to the mounted DOM element or null when unmounted console.log(node) // &lt;a href=\"/\"&gt;跳转吧&lt;/a&gt;}&lt;Link to=\"/\" innerRef={refCallback} &gt;跳转吧&lt;/Link&gt; NavLink Link组件的特殊形式，提供了更多对当前匹配Link的样式控制属性 参数 activeClassName: string 当前URL匹配时，给对应元素添加className的值，默认className=active1&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt;FAQs&lt;/NavLink&gt; activeStyle: object 应用在当前Link的激活样式1&lt;NavLink to=\"/faq\" activeStyle={{fontWeight: \"bold\",color: \"red\"}}&gt;FAQs&lt;/NavLink&gt; exact: bool 为true时，active的样式或者className只会在路由完全匹配时渲染 isActive: func 用于当处理当路由匹配是否激活时，做回调处理123456789101112const oddEvent = (match, location) =&gt; { if (!match) { return false } const eventID = parseInt(match.params.eventID) return !isNaN(eventID) &amp;&amp; eventID % 2 === 1}&lt;NavLink to=\"/events/123\" isActive={oddEvent}&gt;Event 123&lt;/NavLink&gt; location: object 用于isActive函数中的location参数。当不设置location属性时，isActive函数中的location参数默认为当前浏览器的location值，如果设置此属性，则isActive函数中的location参数即为比较此属性的结果12345678910111213const oddEvent = (match, location) =&gt; { if (!match) { //当跳转的url不匹配/events/777时，match即为false return false } const eventID = parseInt(match.params.eventID) return !isNaN(eventID) &amp;&amp; eventID % 2 === 1}&lt;NavLink to=\"/events/123\" isActive={oddEvent} location=\"/events/777\"&gt;Event 123&lt;/NavLink&gt; Redirect 重定向组件，用于在当前路径中，重定向到另一个地址，且在history栈中会替换跳转前的location。类似于服务端重定向(http 3xx) 参数 to:string 重定向到的路径12345678&lt;Redirect to=\"/somewhere/else\" /&gt;&lt;Redirect to={{ pathname: \"/login\", search: \"?utm=your+face\", state: { referrer: currentLocation } }}/&gt; to: object 重定向到的路径,可以多个参数 push: bool 为true时，新location不会替换掉跳转前的location from: string 用于设置从匹配哪个路径时，做重定向跳转。此属性只适用于Redirect组件作为Switch组件的子节点时使用。1234&lt;Switch&gt; &lt;Redirect from='/users/:id' to='/users/profile/:id'/&gt; &lt;Route path='/users/profile/:id' component={Profile}/&gt;&lt;/Switch&gt; exact: bool 为true时，需要完成匹配才生效 WithRouter withRouter可以包装任何自定义组件。其实就是一个高阶组件，通过它生成的组件，会将history,location,match 三个对象传入props中。 应用场景：当需要通过当前URL来做判断，或者需要根据当前URL来做下一步操作时，可以使用withRouter。如做面包屑时需要实时根据path变化作出变化 注意：withRouter并不会自动监听组件状态变化，因此在与redux搭配时，需要这样来：withRouter(connect(...)(MyComponent))1234567891011121314151617181920import React from 'react';import {withRouter} from 'react-router-dom';import PropTypes from 'prop-types';class Header extends React.Component { static propTypes={ history:PropTypes.object.isRequired, match:PropTypes.object.isRequired, location:PropTypes.object.isRequired, }; render() { const {match,history,location}=this.props; return (&lt;div&gt; 顶部{location.pathname} &lt;/div&gt;) }}export default withRouter(Header); 写在最后 React-Router官方示例提供了多种使用React-router的场景，很有用。","link":"/2017/08/06/ReactRouter教程及API/"},{"title":"Vuex要点学习","text":"Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具 devtools extension，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。 目录 安装 核心要点 State状态 Mutation改变 Action行为 Getters GettModule模块ers Getters 安装1npm install vuex 核心要点 Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。 dispatch：操作行为触发方法，是唯一能执行action的方法。 actions：操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。 commit：状态改变,提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。 mutations：状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。 state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。 getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。 Vue组件接收交互行为，调用dispatch方法触发action相关处理，若页面状态需要改变，则调用commit方法提交mutation修改state，通过getters获取到state新值，重新渲染Vue Components，界面随之更新 回顾补充：Readux工作流 简单的应用实例12345678910111213141516171819202122232425// storeconst store = new Vuex.Store({ state:{ count:0 }, mutations:{ increment (state) { state.count++ } }});// componentnew Vue({ el:'#app', computed:{ count:function(){ return store.state.count; } }, methods:{ increment:function(){ store.commit('increment'); } }}) State状态Vuex 使用单一状态树：用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 组件中获取状态 原始方法：在每个组件中import Store来使用，并在组件computed属性中来获取 全局注入应用：在根组件中注册store选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。 mapState函数：当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用mapState 辅助函数帮助我们生成计算属性，让你少按几次键. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 全局注入应用import store from 'xxx';new Vue({ el:'#app', store, components: { Counter }, template: ` &lt;div class=\"app\"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `})// Counter组件中，通过this.$store.state获取const Counter = { template: `&lt;div&gt;{{ count }}&lt;/div&gt;`, computed: { count () { return this.$store.state.count } }}/* 3、mapState函数： 三种使用方式： 1、完全映射覆盖computed（部分属性需处理） 2、完全映射 3、部分映射到属性中*/import {mapState} from 'vuex';export default { //.... computed:mapState({ // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } })}// 若要完全映射state，不需要单独处理state中的某些值，可以直接通过：传入对应状态名即可 computed:mapState(['count','xxx']);// 3、部分映射computed: { localComputed () { /* ... */ }, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState({ // ... })} Mutation改变 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 注意：Mutation必须是同步函数,即在vuex中，mutation是同步事务，若要执行异步事务，请使用actions1234567891011//基础示例new Vuex.Store({ state:{count:0}, mutations:{ increment:function(state){ state.count++; } }})//调用store.commit('increment'); 传入参数（提交载荷（Payload））可以向 store.commit 传入额外的参数，即 mutation 的 载荷（payload），有两种提交参数的方式： 普通参数风格的提交： store.commit('mutation_type',param); 对象参数风格的提交：store.commit({type:'mutation_type',param:10}) 123456789// 传入参数//...mutations:{ increment:function(state,n){ state.count+=n; }}// 调用store.commit('increment',10) 建议：多数情况下建议参数应该以对象的方式提交，这样可以包含多个字段并且记录的 mutation 会更易读： 12345678910// ...mutations:{ increment:function(state,payload){ state.count+=payload.count; }}//调用store.commit('increment', { count: 10}) Mutation 需遵守 Vue 的响应规则 最好提前在Store中声明好所有需要用到的state 当需要在对象上添加新属性时，你应该 使用Vue.set(obj, 'newProp', 123), 或者 以新对象替换老对象：state.obj = { ...state.obj, newProp: 123 } 使用常量替代 Mutation 事件类型 使用常量替代 mutation 事件类型，并用单独的文件来管理所有mutations常量，可以让你的代码合作者对整个 app 包含的 mutation 一目了然： 123456789101112131415161718192021222324// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import { SOME_MUTATION } from './mutation-types'const store = new Vuex.Store({ state: { ... }, mutations: { // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) { // mutate state } }})//componentimport {SOME_MUTATION} from './mutation-types';export default { computed:{ ...mapState({SOME_MUTATION}) }} 注意：Mutation必须是同步函数 在组件中使用mutations两种方法： 通过this.$store.commit('mutation_type')触发 通过mapMutations辅助函数12345678910111213141516import { mapMutations } from 'vuex'export default { // ... methods: { ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` }) }} Action行为Action 类似于 mutation，不同在于： Action提交的是mutaion,而不是直接变更状态。 Action 可以包含任意异步操作。 1234567891011121314151617181920// 注册一个简单的actionconst store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') }, increment2({commit}){ //通过参数解构可以简化代码 commit('increment'); } }}) Action 函数接受一个与 store 实例具有相同方法和属性的context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过context.state 和 context.getters 来获取 state 和 getters。 分发 Action[触发action] 通过store.dispatch()来触发action 在store内触发123456789101112131415161718192021// store.jsactions: { incrementAsync ({ commit }) { setTimeout(() =&gt; { commit('increment') }, 1000) }}// 1. 简单触发store.dispatch('incrementAsync')// 2. 以载荷形式分发(传参)store.dispatch('incrementAsync', { amount: 10})// 3. 以对象参数形式分发store.dispatch({ type: 'incrementAsync', amount: 10}) 一个购物车实例：12345678910111213141516actions: { checkout ({ commit, state }, products) { // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =&gt; commit(types.CHECKOUT_SUCCESS), // 失败操作 () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) }} 在组件中触发Action有两种方式在组件中分发Action: this.$store.dispatch('action_type')，或者mapActions辅助函数12345678910111213141516import { mapActions } from 'vuex'export default { // ... methods: { ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions({ add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` }) }} 组合Action store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise。即store.dispatch后面可以跟then函数实现异步调用组合 1234567891011121314151617181920actions: { actionA ({ commit }) { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { commit('someMutation') resolve() }, 1000) }) }}// 现在你可以store.dispatch('actionA').then(() =&gt; { // ...})// 或者actionB ({ dispatch, commit }) { return dispatch('actionA').then(() =&gt; { commit('someOtherMutation') })} 利用Aysn/Await函数 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: { async actionA ({ commit }) { commit('gotData', await getData()) }, async actionB ({ dispatch, commit }) { await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) }} GettersVuex 允许我们在 store 中定义“getter”（可以认为是store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。1234567891011121314// getters接收state作为第一个参数const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) } }}) 访问Store的Getters有三种访问getter的方式： 通过store的属性方式访问 通过store的方法方式访问 通过mapGetters辅助函数访问1、通过属性方式访问123456789101112131415161718192021222324const store = new Vuex.Store({ state: { todos: [ { id: 1, text: '...', done: true }, { id: 2, text: '...', done: false } ] }, getters: { doneTodos: state =&gt; { return state.todos.filter(todo =&gt; todo.done) }, // 第二个参数是getters可用来访问其他getter doneTodoCount:(state,getters)=&gt;{ return getters.doneTodos.length; } }})// 组件中使用computed: { doneTodosCount () { //属性方式使用 return this.$store.getters.doneTodosCount }} 2、方法访问通过让 getter 返回一个函数，来实现给 getter 传参。在你对 store 里的数组进行查询时非常有用。 注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果。12345678getters: { // ... getTodoById: (state) =&gt; (id) =&gt; { return state.todos.find(todo =&gt; todo.id === id) }}//使用store.getters.getTodoById(2) // -&gt; { id: 2, text: '...', done: false } 3、mapGetters函数mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：1234567891011121314151617import { mapGetters } from 'vuex'export default { // ... computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]), mapGetters({ // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount' }) }} Module模块Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：12345678910111213141516171819202122const moduleA = { state: { ... }, mutations: { ... }, actions: { ... }, getters: { ... }}const moduleB = { state: { ... }, mutations: { ... }, actions: { ... }}const store = new Vuex.Store({ modules: { a: moduleA, b: moduleB }})store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态 在各模块内都拥有各自的state，因此其内部的actions,mutations中的state也指的是当前模块对应的state 对于模块内部的 action，局部状态通过 context.state暴露出来，根节点状态则为context.rootState1234567891011// const moduleA = { // ... actions: { incrementIfOddOnRootSum ({ state, commit, rootState }) { if ((state.count + rootState.count) % 2 === 1) { commit('increment') } } }} 命名空间 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。所以在命名mutaion和action时要防止命名冲突。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store({ modules: { account: { //account模块 namespaced: true, // 模块内容（module assets） state: { ... }, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: { isAdmin () { ... } // -&gt; getters['account/isAdmin'] }, actions: { login () { ... } // -&gt; dispatch('account/login') }, mutations: { login () { ... } // -&gt; commit('account/login') }, // 嵌套模块 modules: { // 继承父模块的命名空间 myPage: { state: { ... }, getters: { profile () { ... } // -&gt; getters['account/profile'] } }, // 进一步嵌套命名空间 posts: { namespaced: true, state: { ... }, getters: { popular () { ... } // -&gt; getters['account/posts/popular'] } } } } }}) 在带命名空间的模块内访问全局内容（Global Assets）如果你希望使用全局 state 和 getter，rootState 和 rootGetter 会作为第三和第四参数传入 getter，也会通过 context 对象的属性传入 action。若需要在全局命名空间内分发 action 或提交 mutation，将 { root: true } 作为第三参数传给 dispatch 或 commit1234567891011121314151617181920212223242526272829303132modules: { foo: { namespaced: true, getters: { // 在这个模块的 getter 中，`getters` 被局部化了 // 你可以使用 getter 的第四个参数来调用 `rootGetters` someGetter (state, getters, rootState, rootGetters) { getters.someOtherGetter // -&gt; 'foo/someOtherGetter' rootGetters.someOtherGetter // -&gt; 'someOtherGetter' }, someOtherGetter: state =&gt; { ... } }, actions: { // 在这个模块中， dispatch 和 commit 也被局部化了 // 他们可以接受 `root` 属性以访问根 dispatch 或 commit someAction ({ dispatch, commit, getters, rootGetters }) { getters.someGetter // -&gt; 'foo/someGetter' rootGetters.someGetter // -&gt; 'someGetter' dispatch('someOtherAction') // -&gt; 'foo/someOtherAction' // 通过设置 {root:true}，则会在全局命名空间内分发 dispatch('someOtherAction', null, { root: true }) // -&gt; 'someOtherAction' commit('someMutation') // -&gt; 'foo/someMutation' commit('someMutation', null, { root: true }) // -&gt; 'someMutation' }, someOtherAction (ctx, payload) { ... } } }} 在带命名空间的模块注册全局 action若需要在带命名空间的模块注册全局 action，你可添加 root: true，并将这个 action 的定义放在函数 handler 中。12345678910111213141516171819{ actions: { someOtherAction ({dispatch}) { dispatch('someAction') } }, modules: { foo: { namespaced: true, actions: { someAction: { root: true, handler (namespacedContext, payload) { ... } // -&gt; 'someAction' } } } }} 带命名空间的绑定函数当使用mapState, mapGetters, mapActions 和 mapMutations 这些函数来绑定带命名空间的模块时，写起来可能比较繁琐 通过使用createNamespacedHelpers创建基于某个命名空间辅助函数。它返回一个对象，对象里有新的绑定在给定命名空间值上的组件绑定辅助函数12345678910111213141516171819202122232425262728//原始：绑定带命名空间的模块methods: { ...mapActions([ 'some/nested/module/foo', // -&gt; this['some/nested/module/foo']() 'some/nested/module/bar' // -&gt; this['some/nested/module/bar']() ])}// 提升：使用createNamespacedHelpersimport { createNamespacedHelpers } from 'vuex'const { mapState, mapActions } = createNamespacedHelpers('some/nested/module')export default { computed: { // 在 `some/nested/module` 中查找 ...mapState({ a: state =&gt; state.a, b: state =&gt; state.b }) }, methods: { // 在 `some/nested/module` 中查找 ...mapActions([ 'foo', 'bar' ]) }} 动态注册模块 当在项目运行过程中，需要新增一个模块来处理Vuex中的状态时，可以用动态注册的方式来增加模块。【模块动态注册功能使得其他 Vue 插件可以通过在 store 中附加新模块的方式来使用 Vuex 管理状态】 如，vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。 在 store 创建之后，你可以使用 store.registerModule 方法注册模块： 使用 store.unregisterModule(moduleName) 来动态卸载模块。12345678910/* 注册模块 `myModule` { preserveState: true }用于保留过去的 state，例如从一个服务端渲染的应用保留 state*/store.registerModule('myModule', { // some modules},{ preserveState: true })// 注册嵌套模块 `nested/myModule`store.registerModule(['nested', 'myModule'], { // ...})","link":"/2017/06/07/Vuex要点学习/"},{"title":"react入门要点汇总","text":"React是一个声明式的，高效的，并且灵活的用于构建用户界面的 JavaScript 库。参考文档-React中文文档 React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 React特点： 声明式设计 −React采用声明范式，可以轻松描述应用。 高效 −React通过虚拟DOM，最大限度地减少与DOM的交互。 灵活 −React可以与已知的库或框架很好地配合。 JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。 组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 目录 安装 JSX语法 React组件 Props属性 State状态 表单与事件 占位子组件Slot 生命周期 状态提升及编程思想 安装 React有两种使用方式：CDN或通过npm安装使用 CDN方式： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;Hello React!&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/react/15.4.2/react-dom.min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/babel-standalone/6.22.1/babel.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"example\"&gt;&lt;/div&gt; &lt;script type=\"text/babel\"&gt; ReactDOM.render(&lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('example') ); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; NPM安装 通过create-react-app脚手架可以快速构建react开发环境，并通过修改App.js入门12345$ npm install react react-dom# 快速构建React开发环境$ npm install create-react-app$ create-react-app my-app$ cd my-app &amp;&amp; npm start JSX语法 JSX是一种JS的语法糖，它执行更快，类型安装。编写React可以不用JSX，但官方推荐使用。 编译之后，JSX 表达式就变成了常规的 JavaScript 对象。因此可以在if或for中使用JSX,用它给变量赋值，或者将它作为函数的返回值。 在JSX内部不能使用if else语句，但可以使用三元运算123456789101112131415// JSX表达式function sayHello(user){ if(user){ return &lt;h1&gt;hello,{user}!&lt;/h1&gt; }else{ return &lt;h1&gt;hello,stranger.&lt;/h1&gt; }}// 三元运算ReactDOM.render( &lt;div&gt; &lt;h1&gt;{i == 1 ? 'True!' : 'False'}&lt;/h1&gt; &lt;/div&gt; , document.getElementById('example')); JSX属性 属性值可以是字符串，也可以是对象 属性名应该使用驼峰命名法，class--&gt;className。【因为JSX比HTML更接近JS】 1234// 1. 属性值-对象const elm=&lt;img className=\"avatar\" src={user.avatarUrl} /&gt;// 2. 属性值-字符串const elm2=&lt;div tabIndex=\"0\"&gt;&lt;/div&gt; JSX样式 React 推荐使用内联样式。 React 会在指定元素数字后自动添加 px 注意：样式名用驼峰写法12345// 行内直接写const elm = &lt;div style={{width:'100px',color:'#fff'}}&gt;红色字体&lt;/div&gt;// 样式对象- const styleElm = {fontSize:100,color:'#ff0'};ReactDOM.render(&lt;h1 style={styleElm}&gt;&lt;/h1&gt;,document.getElementById('app')) React组件 组件(Components) 让你可以将用户界面分成独立的，可复用的小部件，并可以对每个部件进行单独的设计。 从定义上来说， 组件就像JavaScript的函数。组件可以接收任意输入(称为”props”)， 并返回 React 元素，用以描述屏幕显示内容。 组件可分为：函数式组件和类组件两种 参考文章 1234567891011// 函数式组件 - 创建简单，功能单一，常用作一些不变内容的渲染，又称为无状态组件function Welcome(props){ return &lt;h1&gt;Hello,{props.name}&lt;/h1&gt;}// 类组件- 类组件有状态，生命周期等更多特性class Welcome extends React.Component { render (){ return &lt;h1&gt;Hello,{this.props.name}&lt;/h1&gt; }} 注意：组件名称总是以大写字母开始 函数组件：又称为“无状态组件”，“受控组件”或“木偶组件”，因为函数组件只负责接收 props 并返回 UI，它自身并不能拥有可改变的数据，在真实的 React 应用开发场景下，我们经常尽可能的使用函数组件，将整个应用的 UI 拆分成尽可能小的视觉单元。【记住：如果你的组件不需要追踪内部状态，尽量使用函数组件。】 复合组件 使用组件的一大优势在于其可利用性高 复合组件：在一个React组件内部引用了其他组件，从而构成了复合组件 123456789101112131415// 子组件function Avatar(props){ return &lt;img src={props.user.avatarUrl} alt={props.user.name}/&gt;}// 父组件function UserInfo(props) { return ( &lt;div className=\"UserInfo\"&gt; &lt;Avatar user={props.user} /&gt; &lt;div className=\"UserInfo-name\"&gt; {props.user.name} &lt;/div&gt; &lt;/div&gt; );} 注意：JSX最外层只能由一个元素包裹，即return后只能是单个子元素 组件渲染 以下示例介绍几种组件渲染方式，写法：12345678910111213141516171819202122232425262728293031323334353637// 示例1：使用&amp;&amp;操作符-条件渲染// 如果条件为 true ，则 &amp;&amp; 后面的元素将显示在输出中。 如果是 false，React 将会忽略并跳过它。render(){ return ( {true&amp;&amp;&lt;h1&gt;true就显示&lt;/h1&gt;} )}// 示例2：三元运算-条件渲染render(){ return (&lt;div&gt; {isLoggedIn ? ( &lt;LogoutButton onClick={this.handleLogoutClick} /&gt; ) : ( &lt;LoginButton onClick={this.handleLoginClick} /&gt; )} &lt;/div&gt;)}// 示例3：阻止组件渲染// 通过返回null可以防止组件渲染。从组件的 render 方法返回 null 不会影响组件生命周期方法的触发。function WarningBanner(props){ if(!props.warn){ return null; } return (&lt;div&gt;Warning!&lt;/div&gt;)}// 示例4：列表渲染-JSX中使用maprender(){ return ( &lt;ul&gt; {numbers.map((number) =&gt; &lt;ListItem key={number.toString()} value={number} /&gt; )} &lt;/ul&gt; );} Props属性 Props是不可变的，只能读取，不能修改，可以理解为props是从外部传入组件的数据 由于React是单向数据流，所以props基本上也就是从服父级组件向子组件传递的数据。 在React中跟数据有关的三个属性是：state,props,context 参考文档 1234567891011121314// 子组件 item.js 。通过this.props拿值export default class Item extends React.Component{ render(){ return (&lt;li&gt;{this.props.dataItem}&lt;/li&gt;) }}// 父组件import Item from './item.js'export default class Lists extends React.Component{ render(){ const itemLists = data.map(item=&gt;&lt;Item dataItem={item}/&gt;) return ({itemLists}) }} 如上：数据data在通过遍历后，将属性值dataItem传入到子组件中，子组件通过this.props.dataItem接收数据 只读性:props经常被用作渲染组件和初始化状态，当一个组件被实例化之后，它的props是只读的，不可改变的。如果props在渲染过程中可以被改变，会导致这个组件显示的形态变得不可预测。只有通过父组件重新渲染的方式才可以把新的props传入组件中。 默认参数在组件中，我们最好为props中的参数设置一个defaultProps，并且制定它的类型。比如，这样： 1234567Item.defaultProps = { item: &apos;Hello Props&apos;,};Item.propTypes = { item: PropTypes.string,}; 关于propsTypes,可以声明为以下几种类型：1234567optionalArray: PropTypes.array,optionalBool: PropTypes.bool,optionalFunc: PropTypes.func,optionalNumber: PropTypes.number,optionalObject: PropTypes.object,optionalString: PropTypes.string,optionalSymbol: PropTypes.symbol, 总结Props props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。 State状态 一个组件的显示形态可以由数据状态和外部参数所决定，外部参数也就是props，而数据状态就是state。 12345678910111213export default class ItemList extends React.Component{ constructor(){ super(); this.state = { itemList:'一些数据', } } render(){ return ( {this.state.itemList} ) }} 首先，在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。 修改状态(setState) 通过this.setState()来修改state，而不能直接通过this.state做修改 setState有两个参数，状态对象【可以是函数返回值】,状态修改后的回调123456789101112131415161718// 示例：通过异步操作获取数据后，更新statecomponentDidMount(){ fetch('url') .then(response =&gt; response.json()) .then((data) =&gt; { this.setState({itemList:item}); }}// 示例2： 传入回调this.setState({ name:'xb'},()=&gt;console.log('setState 完成'))// 示例3：以函数返回值形式修改State 【这种方式一般是，新状态的值依赖于旧状态】this.setState((prevState) =&gt; ({ name: \"mr.\" + prevState.name})) 注意：通过this.state=来初始化state，使用this.setState来修改state，constructor是唯一能够初始化的地方。 state更新常犯的错 state的更新可能是异步的，因此不要在setState中直接引用this.state.xxx来赋值12345678// 错误代码this.setState({ counter:this.state.counter + this.props.increment})//正确this.setState((state,props)=&gt;{ counter:state.counter+props.increment}) 总结State state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。 State 和Props的区别 state是组件自己管理数据，控制自己的状态，可变； props是外部传入的数据参数，不可变； 没有state的叫做无状态组件，有state的叫做有状态组件； 多用props，少用state。也就是多写无状态组件。 表单与事件 React表单中，最重要的一个概念就是：受控组件。 受控组件：&lt;input&gt;或&lt;select&gt;都要绑定一个change事件;每当表单的状态发生变化,都会被写入组件的state中,这种组件在React中被称为受控组件 使用受控组件需要为每一个组件绑定一个change事件,并且定义一个事件处理器来同步表单值和组件的状态,这是一个必要条件 非受控组件：一个表单组件没有value或checked属性即非受组件。 通过defaultValue和defaultChecked来表示组件的默认状态，它仅会被渲染一次,在后续的渲染时并不起作用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 受控组件class EasyForm extends React.Component{ constructor(){ super(); this.state={ name:'hello', desc:'', job:'' }; this.handleChange=this.handleChange.bind(this); this.submit=this.submit.bind(this); } handleChange(event){ const target = event.target; const value = target.type==='checkbox'?target.checked:target.value; const name = target.name; this.setState({ [name]:value }) console.log(this.state) } submit(){ console.log(this.state) } render() { return ( &lt;form&gt; &lt;label&gt; Name:&lt;input type=\"text\" name=\"name\" value={this.state.name} onChange={this.handleChange}/&gt; &lt;/label&gt; &lt;label&gt; Desc:&lt;textarea name=\"desc\" value={this.state.desc} onChange={this.handleChange}&gt;&lt;/textarea&gt; &lt;/label&gt; &lt;label &gt; Job:&lt;select name=\"job\" value={this.state.job} onChange={this.handleChange}&gt; &lt;option value=\"FE\"&gt;Front End&lt;/option&gt; &lt;option value=\"editor\"&gt;Editor&lt;/option&gt; &lt;option value=\"worker\"&gt;Worker&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;button type=\"button\" onClick={this.submit}&gt;提交&lt;/button&gt; &lt;/form&gt; ); }}// 非受控组件handleSubmit=(e)=&gt;{ e.preventDefault(); console.log(this.refs.nocontrol.value)}render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;input type=\"text\" ref=\"nocontrol\" defaultValue=\"BeiJing\" /&gt; &lt;button type=\"submit\"&gt;Submit&lt;/button&gt; &lt;/form&gt; ); } 如上，通过event.target.name来处理多个多个输入元素 受控组件与非受控组件对比 性能上，由于受控组件值的每次变化都会调用一次onChange事件处理器，会带来性能上的消耗，但这个问题可以通过Flux/Redux应用架构等方式来达到统一组件状态的目的 事件绑定是必要的：使用受控组件需要为每一个组件绑定一个change事件,并且定义一个事件处理器来同步表单值和组件的状态,这是一个必要条件 占位组件Slot 一些组件在设计前无法获知自己要使用什么子组件。这时可以通过children props来直接传递子元素到他们的输出中 也可以通过自定义占位属性来自定义显示组件 1234567891011121314151617181920212223242526272829303132// 示例1：使用props.children显示占位子元素function Wrapper(props){ return ( &lt;div&gt; &lt;h1&gt;哈哈哈哈哈，这是Wrapper的标题&lt;/h1&gt; {props.children} &lt;/div&gt; )}function Print(props){ return ( &lt;Wrapper&gt; &lt;p&gt;这是内部内容。。&lt;/p&gt; &lt;/Wrapper&gt; )}// 示例2：自定义点位属性function Wrapper(props){ return (&lt;div&gt; &lt;h3&gt;这是标签啦。&lt;/h3&gt; &lt;div style={{float:'left'}}&gt;{props.left}&lt;/div&gt; &lt;div style={{float:'right'}}&gt;{props.right}&lt;/div&gt; &lt;/div&gt;)}class Slot extends React.Component { render() { return ( &lt;div&gt; &lt;Wrapper left={&lt;Left /&gt;} right={&lt;Right /&gt;}&gt;&lt;/Wrapper&gt; &lt;/div&gt;) }} 生命周期组件的生命周期分成三个状态： ① Mounting：已插入真实DOM ② Updating：正在被重新渲染 ③ Unmounting：已移除真实DOM React 为每个状态都提供了两种处理函数，will函数在进入状态之前调用，did函数在进入状态之后调用，共计五种处理函数： ① componentWillMount() ② componentDidMount() ③ componentWillUpdate(object nextProps, object nextState) ④ componentDidUpdate(object prevProps, object prevState) ⑤ componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数： ① componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 ② shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 有关组件的生命周期的详细介绍请见：http://blog.csdn.net/zhouziyu2011/article/details/71172783 状态提升及编程思想状态提升 React中的状态提升概括来说,就是将多个组件需要共享的状态提升到它们最近的父组件上.在父组件上改变这个状态然后通过props分发给子组件. 应用场景：当同一个数据的变化需要几个组件都作出反映时，建议提升共享的状态到它们最近的祖先组件中 示例代码可参考：官网案例-温度转换器 编程思想 参考好文：浅谈React编程思想、官方方案","link":"/2017/06/05/react入门要点汇总/"}],"tags":[{"name":"个人","slug":"个人","link":"/tags/个人/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"教程资源","slug":"教程资源","link":"/tags/教程资源/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"CentOS","slug":"CentOS","link":"/tags/CentOS/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/随笔/"},{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"后端学习","slug":"后端学习","link":"/categories/后端学习/"},{"name":"H5","slug":"H5","link":"/categories/H5/"},{"name":"前端学习","slug":"前端学习","link":"/categories/前端学习/"},{"name":"前端开发","slug":"前端开发","link":"/categories/前端开发/"}]}