{"pages":[{"title":"about","text":"我就是我。。。。 颜色不一样的。。。大呀大呀大呀呵呵you and meyou need to see my design666666 啊啊啊哈哈哈哈哈军人的圣诞哈哈哈哈军人的圣诞oh myYouth is not a time of life,it is a state of mindit is not a matter of rosy cheeks,red lips adn supple knees.it is a matter of will,a auality of the imagination,a vigor of the emotions;it is the freshness of the deep springs of life.Youth means a temperamental predominance of courage over timidity, of the appetite for adventure over the love of ease.this often exists in a man of sixty more than a boy of twentynobody grows old merely by a number of yearswe grow old by deserting our ideals.Years may wrinkle the skin,but to give up enthusiasm wrinkles the soul.Worry,fear,self-distrust bows the heart and turns the spirit back to dust.whether sixty of sixteen,there is in every human being’s heart the lure of wonder,the unfailing child-like appetite of what’s next, Github MarketplaceTools to build on and improve your workflowAppVeyor: Cloud service for building,testing adn deploying Windows apps.MyGet: Artifact and Package Repositories:Hosted NuGet,npm,Bower,Maven,PHP Composer and VSIX feeds and build servicesCloud 66 for Rails:Build deploy,and maintain your Rails apps on any cloud or serverPull Reminders:Slack reminders and metrics for pull requestsCode qualityAutomate your code review with style,quality,security,and test-coverage checks when you need them.Sider:Detect anti-pattern instances and apply projet best practices in your pull requests automatically.Easy and quicck setupCodecov:Group,merge,archive and compare coverage reportsCode Climate:Autoomated code review for technical debt and test coverageBetter Code Hub:A shared Definition of Done for code qualityCoveralls:Ensure that new code is fully covered,and see coverage treends emerge.Works with any CI servicescodebeat:Code review export on demand.Automated for mobile and webImgBot:A Github app that optimizes your imagesCodacy:Automated code reviews to help developers ship better software,fasterContinuous integration:Automatically build and test your code as you push it to GitHub,preventing bugs from being deployed to productionAccessLint:Find accessibility issues in your pull requestsTravis CI:Test and deploy with confidenceBuddy: One-click delivery automation for Web DevelopersPercy:Continuous visual testing and reviews for web appsSemaphore: Test and deploy at the push of a buttonAppVeyor:Cloud service for building,testing and deploying Windows appsCloud 66 Skycap:Skycap is a container native CI/CD toolCircleCI:Automatically build,test,and deploy Your project in minutesMonitoring：Monitor the impact of your code changes,Measure performance,track errors,and analyze your application.Airbrake:real time error monitoring and alertsSentry:Real-time,cross-platform crash reporting and error loggin.Moesif API Insights:API debugging and analytics for REST,GraphQL,and Web3 APIsLogRocket:Record videos of user sessions with enhanced logging information.Rollbar:Real-time,full-stack error monitoring and debugging for developers.Project management:Organize,manage,and track your project with tools that build on top of issues and pull requests.GitKraken Glo Boards:Free issue/task tracking boards that sync in real-time with GitHub IssuesZenHub:Agile Task Boards,Epics,Estimates and Reports,all within GitHub’s UI","link":"/about/index.html"}],"posts":[{"title":"JavaScript模式【O'Reilly出版】·附网盘链接","text":"模式：指一个通用问题的解决方案。一个模式不仅仅是一个可以用来复制粘贴的代码解决方案，更多地是提供了一个更好的实践经验、有用的抽象化表示和解决一类问题的模板。 目录 PDF地址 基本技巧 字面量和构造函数 PDF地址 网盘地址：https://pan.baidu.com/s/1Kwgim2OQL86hSGjZftTR4Q 云盘密码：qizu 基本技巧编写可维护的代码易维护的代码意味着代码具有如下特性: 阅读性好 具有一致性 预见性好 看起来如同一个人编写 有文档 尽量少用全局变量 变量释放时的副作用 全局变量不能通过delete删除，而对象的属性可以 编码时的建议 单一的var模式：在函数内部，将变量的定义放在函数头部,便于维护，提高代码要读性。 对for循环的建议： 逐步减至0，这样通常更快，因为同0比较比同数组的长度比较，或者同非0数组比较更有效率。 实践证明，while循环速度更快 123var i,arr=[];// 改进：使用while循环while(i--){//xxx} 对for…in循环的建议： for...in又称为枚举,用于处理对象。在遍历对象属性来过滤遇到原型链的属性时，可通过obj.hasOwnProperty|Object.property.hasOwnProperty.call(xxx)来检测key是否为对象本身属性。 不要增加内置的原型 避免使用隐式类型转换：为避免隐式类型转换导致的混乱，在使用比较廒时，应该使用===或!===来对数值和类型进行比较 避免使用eval() parseInt()数值约定：在使用parseInt时，最好不要忽略第二个参数（进制），因为带val第一位是0时，其会被当做一个八进制数进行处理【例如处理09这种月份日期时】，最佳实践：parseInt(num,10) 空格的使用 ： 在for循环的各个部分的分号后，建议添加空格，for(var i=0, max=4; i&lt;max; i++){} 在限定数组项的逗号后面： var a = [ 1, 2, 3] 分隔开函数中各个参数的逗号之后 ： myFun = function(a, b, c) 在函数声明的大括号之前 : function myFun() {} 在匿名函数表达式之后 ： var myFun = function () {} 命名约定 构造函数的首字母大写 针对多个单词组成的变量名，推荐使用驼峰式命名法或下划线连接 常量命名通常使用全大写的方式 私有变量命名通常给变量名加下划线前缀var _private = 1 编写API文档 API文档可以从代码的注释中自动生成。 在JS中，推荐两个开源工具可用于编写JS文档，分别是JSDoc Toolkit和YUIDoc 生成API文档的步骤如下： 编写特殊格式的代码块 运行工具来解析代码和注释 发布工具解析的结果，大多数情况是采用HTML格式发布 示例：有一个名为reverse()的函数，可以将字符串翻转过来，该函数有一个字符串参数，并返回另一个字符串 1234567/*** 翻转一个字符串* * @param {String} 输入需要翻转的字符串* @return {String} 翻转后的字符串*/var reverse = function (input) {return output;} 在正式发布时，精简代码 字面量和构造函数","link":"/2018/02/10/JS模式/"},{"title":"nodemon-解决开发时无限npm start的痛点","text":"刚开始学习Node时，每次做了修改，都要重新npm start启动服务才能查看上次修改结果，而nodemon就是为了开发node时进行热更新的一款工具 目录 -安装-配置nodemon 安装 先全局安装，再以开发依赖形式安装 1234# 全局安装npm install nodemon -g# 依赖安装npm install nodemon -D 配置nodemon 新建nodemon.json文件默认为nodemon的配置文件，从而进行自定义启动配置 也可以直接在package.json中新增nodemonConfig字段进行配置 123456789101112131415{ \"restartable\":\"rs\", \"verbose\": true, \"ignore\":[ \".git\", \".svn\", \"node_modules/**/node_modules\" ], \"execMap\": { \"js\": \"node --harmony\" }, \"env\":{ \"NODE_ENV\": \"development\" }} 配置项说明：属性|说明—|—restartable|设置重启模式verbose|设置日志输出模式，true为详细模式ignore|设置忽略文件execMap|设置运行服务的后缀名与对应的命令watch|监听哪些文件的变化，当变化时行动重启ext|监控指定的后缀文件名 123\"execMap\":{ \"js\":\"node -harmony\"} 表示使用nodemon代替node 启动服务 nodemon ‘./bin/www.js'","link":"/2017/10/25/nodemon/"},{"title":"vue打包优化","text":"通常在使用Vue开发单面应用时，由于第三方库大都是在main.js中进行引用的，而webpack在打包时，会将所引用的第三方库都打包到vendor.js中，导致vendor.js过大。针对这个问题可以进行以下优化： 优化方案 使用CDN引用第三方库 vue-router懒加载 CDN引用 可以使用的CDN很多，例如： unpkg就是全球好用的CDN12// https://unpkg.com/包名@version/ ,不加@version的话，则是默认最新版本&lt;script src=\"https://unpkg.com/vue@2.5.2/dist/vue.min.js\"&gt;&lt;/script&gt; 例： 将vue和iview以CDN的方式引用到项目中 步骤一:引用CDN12345&lt;script src=\"https://unpkg.com/vue@2.5.2/dist/vue.js\"&gt;&lt;/script&gt;&lt;!-- 生产环境，改用vue.min.js --&gt;&lt;!--&lt;script src=\"https://unpkg.com/vue@2.5.2/dist/vue.min.js\"&gt;&lt;/script&gt;--&gt;&lt;script src=\"https://unpkg.com/iview/dist/iview.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/echarts/4.2.0-rc.1/echarts.common.min.js\"&gt;&lt;/script&gt; 在引用后，默认Vue，iview是全局变量可以直接拿到，针对iview的一些修改，可以直接用iview变量 注意： iview使用CDN方式时，其Form组件应使用i-form，而&lt;FormItem&gt;对应&lt;form-item&gt; 例：调用iview的loadingBar,iview.loadingBar.start() 步骤二：修改webpack12345678910// webpack.base.conf.jsmodule.exports={ //.... externals:{ 'vue':'Vue', 'iview':'iView', 'echarts':'echarts' }, //...} vue-router懒加载 通常我们在写router时，时以下方式 123456import Hello from '@/components/Hello.vue'export const router=[{ path:'/', name:'home', component:Hello}] 这种方式会将所有组件都打包在一些，导致打包文件很大。 改进12345export const router=[{ path:'/', name:'home', component:()=&gt;import('@/components/Hello.vue')}] 通过vue-router懒加载，你会发现打包后，会有很多js文件生成，这些都是对应不同组件，当匹配到某路由时，才会加载对应js","link":"/2018/01/10/vue打包优化/"},{"title":"MarkDown语法汇总","text":"本文主要记录Markdown相关编写语法以及Hexo博客编写语法 文章头部123456789101112---title: 标题date: 时间banner: 首页展示bannerthumbnail: images/deer.jpg # 注意此本地图片目录结构为 source/images/deer.jpg，不要放到主题下的images中去tag: 标签 categories: 分类# 阅读更多的标记&lt;!--more--&gt; --- 段落语法 这是一个段落呀 自定义目录 1.1 1.2 123[标题一](#目录跳转标题)- [1.1](#功能快捷键)- [1.2](#新的改变) 功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G 合理的创建标题，有助于目录的生成直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 123456*强调文本* _强调文本_**加粗文本** __加粗文本__==标记文本==~~删除文本~~&gt; 引用文本 插入链接与图片链接: Sophie’s World. 图片: 带尺寸的图片: 123链接: [Sophie&apos;s World](https://sophieu.github.io/SophieU/).图片: ![Alt](http://tylingsoft.com/img/mdm/icon.png)带尺寸的图片: &lt;img src=&quot;http://tylingsoft.com/img/mdm/icon.png&quot; width=&quot;20px&quot; height=&quot;20px&quot;/&gt; 如何插入一段漂亮的代码片去博客设置页面，选择一款你喜欢的代码片高亮样式，下面展示同样高亮的 代码片 12// An highlighted blockvar foo = 'bar'; 生成一个适合你的列表 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建一个表格一个简单的表格是这么创建的： 项目 Value 电脑 $1600 手机 $12 导管 $1 设定内容居中、居左、居右使用:---------:居中使用:----------居左使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 创建一个自定义列表 目录1 缩进一 缩进二 123* 目录1 + 缩进一 + 缩进二 如何创建一个注脚一个具有注脚的文本。^2","link":"/2018/09/25/站点简介/"},{"title":"Node Web开发框架-Express","text":"Express是基于Node.js平台的极简的经典Web开发框架。中文官网 目录 安装 HelloWorld Express应用生成器 Router路由 静态文件 中间件 模板引擎 Express设置代理 常见问题 安装 前提：已安装Node.js 12345678$ mkdir myapp$ cd myapp# 初始化文件[中间会出现一些询问命令按需进行]$ npm init# 安装$ npm install express -S HelloWorld myapp目录下，新建app.js作为入口文件 示例：用express创建一个简单的web服务123456const express = require('express')const app = express()app.get('/', (req, res) =&gt; res.send('Hello World!'))app.listen(3000, () =&gt; console.log('Example app listening on port 3000!')) 1node app.js 访问localhost:3000可以看到页面显示了Hello World，访问其他页面会出现404，这就是一个简单的web应用服务 Express应用生成器 express提供了用于快速生成一个web应用程序的工具express-generator，它可以快速创建项目骨架，并包含多个基本应用模块 123456789# 安装$ npm install express-generator -g# 查看express指令$ express -h# 创建一个以ejs为模板引擎的应用$ express --view=ejs myapp# 启动应用[默认是在3000端口启动]$ npm start 通过生成器创建的应用一般都有如下目录结构： 1234567891011121314151617.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.pug ├── index.pug └── layout.pug Router路由路由：决定了应用如何响应客户端请求，针对请求不同的URI或Path，以及不同的请求方式（get/post），会作出不同的响应 app是express的实例，METHOD对应前端请求方式，PATH对应前端请求路径，HANDLER对应当匹配路由时的响应函数 12345678910111213//get请求app.get('/next',function(req,res,next){ res.send('针对next的请求');})// post请求app.post('/set',function(req,res,next){ res.send('这是一个post请求')})//所有请求app.all('/all',functino(req,res,next){ console.log('进到了/all') next();}) app.all()比较特殊，主要用于对所有请求都加载中间件函数 在项目中，路由都是分模块的，如上，index则代表主要首页模块，在routes/index文件中，又有多个路由可参考写法。 路由参数（parameters） 参考文档 路由路径中，?, +, *, ()可以正则的方式来匹配路径 req.params中可以获取到通过请求url/:param下的参数param 1234567891011121314// 1、正则匹配[示例匹配abe或abcde]app.get('/ab(cd)?e',function(req,res){ res.send('ab(cd)?e')})// 2、req.params的使用Route path: /users/:userId/books/:bookIdRequest URL: http://localhost:3000/users/34/books/8989req.params: { \"userId\": \"34\", \"bookId\": \"8989\" }// 3、params的扩展使用，()匹配Route path: /user/:userId(\\d+)Request URL: http://localhost:3000/user/42req.params: {\"userId\": \"42\"} 路由回调 app.get('url',callback)：其中callback回调可以是一个函数，也可以是一个函数构成的数组，也可以是数组加函数，详见文档 route支持链式调用1234567app.route(&apos;/book&apos;) .get(function (req, res) { res.send(&apos;Get a random book&apos;) }) .post(function (req, res) { res.send(&apos;Add a book&apos;) }) Response方法 方法名 作用 res.download() 提供一个文件下载 res.end() 终止响应进程 res.json() 返回json对向响应 res.jsonp() 响应一个jsonp格式的json对向 res.redirect() 重定向 res.render() 向前端渲染一个模板 res.send() 发送通用类型的响应 res.sendFile() 以文件流方式发送文件 res.sendStatus() 设置响应code，并发送响应 express.Router 路由模块 项目中，通常路由是按模块来区分的，而不是全部写在app.js中，如下：123456789101112131415161718192021// index.jsvar express = require('express');var router = express.Router();// 使用中间件router.use(function timelog(req,res,next){ console.log('Time: ', Date.now()) next()})// 路由router.get('/', function (req, res) { res.send('Birds home page')})router.get('/about', function (req, res) { res.send('About birds')})// app.js中var index = require('./router/index.js')app.use('/',index); 静态文件 为了提供诸如图像、CSS 文件和 JavaScript 文件之类的静态文件，可以使用 Express 中的express.static内置中间件函数。 示例：访问public目录下的所有文件 123456789app.use(epxress.static('public'))// 若要使用多个静态资源目录，则多次调用express.static中间件函数// '/static'设置前缀地址来访问资源app.use('/static',express.static('public'))app.use(express.static('files'))// 通常的做法app.use('/static', express.static(path.join(__dirname, 'public'))) 中间件 中间件函数可以处理请求对象(req)，响应对象(res)，以及next函数。通常中间件是用来对请求或响应进行包装和处理。 示例– 添加一个 myLogger中间件（用于打印日志）和一个requestTime中间件用于展示请求时间 12345678910111213141516171819202122// web应用const express = require('express');const app = new express();// myLogger中间件var myLogger = function(req,res,next){ console.log('LOGGER') next();}app.use(myLogger); //使用中间件// requestTime中间件var requestTime = function(req,res,next){ req.requestTime = Date.now(); next();}app.use(requestTime); //使用中间件app.get('/',function(req,res){ res.send('Hello U')})app.listen(3000) 可配置的中间件 例如express的cookieSession中间件，可用于处理用户session1234567891011// my-middleware.jsmodule.exports = function(options) { return function(req, res, next) { // 基于options选项来执行逻辑 next() }}//使用var mw= requrie('./my-middleware.js');app.use(mw(option1:'1',option2:'2')) 第三方中间件 cookie-parser：用于处理123456var express = require(&apos;express&apos;)var app = express()var cookieParser = require(&apos;cookie-parser&apos;)// load the cookie-parsing middlewareapp.use(cookieParser()) 模板引擎 通过app.set('view engine', 'ejs')可设置模板引擎 通过app.set('views','./views')可设置渲染模板 1234// 设置模板app.get('/', function (req, res) { res.render('index', { title: 'Hey', message: 'Hello there!' })}) Express设置代理 文档 通过app.set('trust proxy',params)来设置代理，params有多种可能，如下： Boolean值：为true时，激活反向代理，默认未激活状态false 数据库集成 详见文档 常见问题1. 如何处理404响应 在Express中，404响应不是错误，所以需要一个针对404的中间件来捕获它 123app.use(function (req, res, next) { res.status(404).send(\"Sorry can't find that!\")}) 当然，也可以用设置好的404页面通过res.render的方式渲染到客户端 2. 设置一个错误处理器 express生成的项目中，默认是有捕获错误的中间件的，当然也可以自己写，如下示例： 在异步函数中，必须要使用next()来传递错误给express并捕获相应错误 12345678910111213141516171819202122232425262728// 简单的错误处理中间件app.use(function (err, req, res, next) { console.error(err.stack) res.status(500).send('Something broke!')})// 异步函数中的错误处理app.get(\"/\", function (req, res, next) { fs.readFile(\"/file-does-not-exist\", function (err, data) { if (err) { next(err); // 将错误传递给express } else { res.send(data); } });});// express生成项目中，默认的处理器app.use(function(err, req, res, next) { // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get('env') === 'development' ? err : {}; // render the error page res.status(err.status || 500); res.render('error');});","link":"/2016/10/25/Express/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Node","slug":"Node","link":"/tags/Node/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"}],"categories":[{"name":"读书笔记","slug":"读书笔记","link":"/categories/读书笔记/"},{"name":"后端学习","slug":"后端学习","link":"/categories/后端学习/"},{"name":"前端开发","slug":"前端开发","link":"/categories/前端开发/"},{"name":"随笔","slug":"随笔","link":"/categories/随笔/"}]}